<!DOCTYPE html>
<html lang="en">
<head>
    <!-- 
        This is the HEAD section - it contains metadata about the page
        and styles (CSS) that make the page look nice
    -->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quotation Generator</title>
    
    <style>
        /* 
            ============================================
            CSS STYLES - This makes the page look nice
            ============================================
            CSS controls colors, fonts, spacing, and layout
        */
        
        /* Reset default browser styles */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        /* Brand color */
        :root {
            --brand-color: #3b3f79;
        }

        /* Body styles - the main container */
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f5f5f5;
            padding: 0;
            line-height: 1.6;
        }
        
        /* Container - wraps all content */
        .container {
            max-width: 100%;
            margin: 0;
            background-color: white;
            padding: 20px;
            border-radius: 0;
            box-shadow: none;
        }
        
        /* Page title */
        h1 {
            color: #333;
            margin-bottom: 30px;
            text-align: center;
        }
        
        /* Section titles */
        h2 {
            color: #555;
            margin-top: 30px;
            margin-bottom: 15px;
            border-bottom: 2px solid var(--brand-color);
            padding-bottom: 10px;
        }
        
        /* Input section styling */
        .input-section {
            margin-bottom: 30px;
        }
        
        /* Labels for form fields */
        label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
            color: #333;
        }
        
        /* Text area for email content */
        textarea {
            width: 100%;
            min-height: 150px;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
            font-family: inherit;
            resize: vertical; /* Allow vertical resizing only */
        }
        
        /* File input styling */
        input[type="file"] {
            width: 100%;
            padding: 10px;
            border: 2px dashed #4CAF50;
            border-radius: 4px;
            background-color: #f9f9f9;
            cursor: pointer;
        }
        
        /* Generate button */
        .generate-btn {
            background-color: #4CAF50;
            color: white;
            padding: 15px 30px;
            border: none;
            border-radius: 4px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            width: 100%;
            margin-top: 20px;
            transition: background-color 0.3s;
        }
        
        /* Button hover effect */
        .generate-btn:hover {
            background-color: #45a049;
        }
        
        /* Button when clicked */
        .generate-btn:active {
            background-color: #3d8b40;
        }
        
        /* Approve button */
        .approve-btn {
            background-color: #2196F3;
            color: white;
            padding: 15px 30px;
            border: none;
            border-radius: 4px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            width: 100%;
            margin-top: 20px;
            transition: background-color 0.3s;
        }
        
        /* Approve button hover effect */
        .approve-btn:hover {
            background-color: #1976D2;
        }
        
        /* Approve button when clicked */
        .approve-btn:active {
            background-color: #1565C0;
        }
        
        /* Upload button */
        .upload-btn {
            background-color: #9C27B0;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        
        .upload-btn:hover {
            background-color: #7B1FA2;
        }
        
        .upload-btn:active {
            background-color: #6A1B9A;
        }
        
        /* Save button */
        .save-btn {
            background-color: #FF9800;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            margin-top: 15px;
            transition: background-color 0.3s;
        }
        
        /* Save button hover effect */
        .save-btn:hover {
            background-color: #F57C00;
        }
        
        /* Save button when clicked */
        .save-btn:active {
            background-color: #E65100;
        }
        
        /* Saved quotation styling */
        .quotation-saved {
            border-color: #FF9800 !important;
            background-color: #FFF3E0 !important;
        }
        
        .quotation-saved h3 {
            color: #FF9800 !important;
        }
        
        .saved-badge {
            display: inline-block;
            background-color: #2e7d32;
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: bold;
            margin-left: 10px;
            text-transform: uppercase;
        }

        .assigned-badge {
            background-color: #1976d2;
        }

        .approval-layout {
            display: flex;
            gap: 16px;
            align-items: stretch;
            position: relative;
        }

        .approval-quotation {
            flex: 1 1 0;
            min-width: 0;
        }

        .approval-quotation table {
            width: 100%;
        }

        .approval-side {
            flex: 0 0 520px;
            max-width: 580px;
        }

        .approval-resize-handle {
            width: 6px;
            height: 100%;
            cursor: col-resize;
            border-radius: 4px;
            background: #9e9e9e;
            flex: 0 0 6px;
            margin-top: 0;
            box-shadow: inset 0 0 0 1px #7f7f7f;
            align-self: stretch;
        }

        .approval-quotation {
            font-size: 12px;
        }

        .approval-scroll-panel {
            overflow: visible;
        }

        .approval-drag-area {
            position: relative;
            min-height: 120px;
        }

        .approval-drag-panel {
            position: relative;
            cursor: grab;
        }

        .approval-drag-panel.dragging {
            cursor: grabbing;
            user-select: none;
        }

        .approval-drag-handle {
            font-size: 11px;
            color: #666;
            margin-bottom: 6px;
        }

        .email-table-preview table {
            width: 100%;
            border-collapse: collapse;
            table-layout: fixed;
            font-size: 12px;
        }

        .email-table-preview th,
        .email-table-preview td {
            border: 1px solid #ddd;
            padding: 4px 6px;
            text-align: left;
            vertical-align: top;
            word-break: break-word;
        }

        .email-html-preview {
            white-space: pre-wrap;
            font-size: 12px;
            background: #fafafa;
            border: 1px solid #eee;
            padding: 8px;
            border-radius: 4px;
            overflow-y: visible;
            overflow-x: auto;
        }

        .email-html-preview table {
            white-space: normal;
            width: 100%;
            border-collapse: collapse;
            table-layout: auto;
        }

        .email-html-preview th,
        .email-html-preview td {
            white-space: normal;
            word-break: break-word;
        }

        .email-html-preview th,
        .email-html-preview td {
            border: 1px solid #ddd;
            padding: 4px 6px;
            text-align: left;
            vertical-align: top;
            word-break: break-word;
        }

        .email-table-preview table {
            width: 100%;
            border-collapse: collapse;
            font-size: 12px;
        }

        .email-table-preview th,
        .email-table-preview td {
            border: 1px solid #ddd;
            padding: 4px 6px;
            text-align: left;
            vertical-align: top;
        }

        @media (max-width: 900px) {
            .approval-layout {
                flex-direction: column;
            }
            .approval-side {
                flex: 1 1 auto;
                max-width: none;
                width: 100%;
            }
        }
        
        /* Folder-like styling for saved quotations */
        .quotation-folder {
            background-color: #f5f5f5;
            border: 2px solid #ddd;
            border-radius: 4px;
            margin-bottom: 10px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .quotation-folder:hover {
            background-color: #e8e8e8;
            border-color: #FF9800;
        }
        
        .quotation-folder-header {
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: bold;
            color: #333;
        }
        
        .quotation-folder-header .folder-icon {
            margin-right: 10px;
            font-size: 18px;
        }
        
        .quotation-folder-content {
            display: none;
            padding: 20px;
            background-color: white;
            border-top: 2px solid #ddd;
        }
        
        .quotation-folder-content.show {
            display: block;
        }
        
        .folder-toggle-icon {
            font-size: 20px;
            transition: transform 0.3s;
        }
        
        .folder-toggle-icon.open {
            transform: rotate(90deg);
        }
        
        /* Quotation display section - always visible */
        .quotation-section {
            display: block;
            margin-top: 40px;
            padding: 20px;
            background-color: #f9f9f9;
            border-radius: 4px;
        }

        .config-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 12px;
        }

        .config-toggle-btn {
            background-color: var(--brand-color);
            color: #fff;
            border: none;
            padding: 8px 14px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
        }

        .config-toggle-btn:hover {
            background-color: #2f3268;
        }
        
        /* Quotation header layout */
        .quotation-header {
            background-color: #ffffff;
            color: #333;
            padding: 20px;
            border: 1px solid #ddd;
            border-radius: 4px;
            margin-bottom: 30px;
        }

        .quote-header-top {
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 2px solid var(--brand-color);
            padding-bottom: 10px;
            margin-bottom: 12px;
        }

        .logo-placeholder {
            width: 80px;
            height: 80px;
            border: none;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            color: var(--brand-color);
            overflow: hidden;
        }

        .logo-placeholder img {
            max-width: 100%;
            max-height: 100%;
            display: block;
        }

        .company-info {
            flex: 1;
            margin-left: 16px;
        }

        .company-info h3 {
            margin: 0;
            font-size: 18px;
            font-weight: bold;
        }

        .company-info p {
            margin: 2px 0;
            font-size: 12px;
        }

        .quote-title {
            font-size: 24px;
            font-weight: bold;
            color: var(--brand-color);
        }

        .quote-meta {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            font-size: 12px;
            margin-bottom: 12px;
        }

        .quote-meta .meta-row {
            display: flex;
            justify-content: space-between;
        }

        .bill-ship {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            border-top: 1px solid #ddd;
            padding-top: 10px;
            font-size: 12px;
        }

        .terms-box {
            margin-top: 16px;
            padding: 0;
            font-size: 14px;
            background: transparent;
        }

        .terms-box h4 {
            margin: 0 0 12px 0;
            font-size: 15px;
        }

        .terms-box ol {
            margin: 0;
            padding-left: 16px;
        }

        .terms-box textarea,
        .terms-textarea {
            min-height: 380px;
            resize: vertical;
        }

        .terms-divider {
            margin-top: 22px;
            border: 0;
            border-top: 1px solid #ddd;
        }
        
        /* Table styling */
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 30px;
            background-color: white;
        }
        
        /* Table header */
        th {
            background-color: var(--brand-color);
            color: white;
            padding: 10px;
            text-align: left;
            font-weight: bold;
            font-size: 12px;
            border: 1px solid white;
        }
        
        /* Table cells */
        td {
            padding: 8px;
            border: 1px solid white;
            font-size: 12px;
        }
        
        /* Alternate row colors for readability */
        tr:nth-child(even) {
            background-color: #f2f2f2;
        }
        
        /* Editable input styling */
        input[type="text"], input[type="number"] {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
            background-color: white;
        }
        
        /* Pipe type header row styling */
        .pipe-type-header {
            background-color: var(--brand-color);
            color: white;
            font-weight: bold;
            font-size: 16px;
        }

        .pipe-type-header td {
            padding: 15px 12px;
            border: 1px solid white;
            border-bottom: 2px solid #333;
            background-color: var(--brand-color);
        }

        .pipe-type-header input {
            width: 100%;
            border: none;
            background: transparent;
            color: white;
            font-weight: bold;
            font-size: 14px;
        }
        
        /* Subtotal row styling */
        .subtotal-row {
            background-color: #e8f5e9;
            font-weight: bold;
        }
        
        .subtotal-row td {
            padding: 12px;
            border: 1px solid white;
            border-top: 2px solid var(--brand-color);
            border-bottom: 2px solid var(--brand-color);
        }
        
        /* Grand total section */
        .grand-total {
            margin-top: 20px;
            padding: 15px;
            background-color: var(--brand-color);
            color: white;
            text-align: right;
            font-size: 20px;
            font-weight: bold;
            border-radius: 4px;
        }
        
        /* Info message */
        .info-message {
            background-color: #e7f3ff;
            border-left: 4px solid #2196F3;
            padding: 15px;
            margin-bottom: 20px;
            border-radius: 4px;
        }
        
        /* Error message */
        .error-message {
            background-color: #ffebee;
            border-left: 4px solid #f44336;
            padding: 15px;
            margin-top: 20px;
            border-radius: 4px;
            color: #c62828;
            display: none;
        }
        
        .error-message.show {
            display: block;
        }
        
        /* Header editable input styling */
        .header-editable {
            font-family: inherit;
            font-size: inherit;
        }
        
        .header-editable::placeholder {
            color: rgba(255, 255, 255, 0.7);
        }
        
        /* Approved quotation item styling */
        .approved-quotation-item {
            margin-bottom: 40px;
            padding: 20px;
            background-color: white;
            border: 2px solid var(--brand-color);
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        
        .approved-quotation-item:last-child {
            margin-bottom: 0;
        }
        
        .approved-quotation-item h3 {
            color: var(--brand-color);
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid var(--brand-color);
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
</head>
<body>
    <!-- 
        ============================================
        HTML BODY - This is what users see on screen
        ============================================
    -->
    
    <div class="container">
        <!-- Main title -->
        <h1>ðŸ“‹ Quotation Generator</h1>
        
        <!-- Info message explaining the app -->
        <div class="info-message">
            <strong>How to use:</strong> Upload rate file and instructions first, then paste email content and/or upload a file, then click "Generate Quotation".
        </div>
        
        <!-- Configuration Section: Upload rate file and instructions -->
        <div class="input-section" id="configSection">
            <div class="config-header">
                <h2 style="margin: 0;">Upload Price List</h2>
                <button class="config-toggle-btn" type="button" onclick="toggleConfigSection()">Show</button>
            </div>
            
            <div id="configContent" style="display: none; margin-top: 16px;">
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;">
                    <!-- Rate File Upload (Multiple) -->
                    <div>
                        <label for="rateFileUpload">Upload Rate Files (Excel or PDF) - You can select multiple:</label>
                        <input type="file" id="rateFileUpload" accept=".xlsx,.xls,.pdf" multiple style="margin-top: 8px;">
                        <div id="rateFilePreview" style="margin-top: 8px;"></div>
                        <button type="button" class="upload-btn" onclick="uploadRateFile()" style="margin-top: 10px; width: 100%;">
                            ðŸ“¤ Upload Rate Files
                        </button>
                        <p id="rateFileStatus" style="margin-top: 8px; font-size: 12px; color: #666;"></p>
                        <div id="uploadStatusBanner" style="display:none; margin-top:10px; padding:10px; border-radius:4px; font-size:14px;"></div>
                    </div>
                    
                    <!-- Instructions Text Input -->
                    <div>
                        <label for="instructionsText">AI Instructions (paste your instructions here):</label>
                        <textarea id="instructionsText" placeholder="Paste your AI instructions here..." style="width: 100%; min-height: 100px; padding: 8px; margin-top: 8px; border: 2px solid #ddd; border-radius: 4px; font-family: inherit;"></textarea>
                        <button class="upload-btn" onclick="saveInstructions()" style="margin-top: 10px; width: 100%;">
                            ðŸ’¾ Save Instructions
                        </button>
                        <p id="instructionsStatus" style="margin-top: 8px; font-size: 12px; color: #666;"></p>
                    </div>
                </div>
                
                <!-- Default Terms and Conditions -->
                <div style="margin-top: 20px;">
                    <label for="defaultTermsConfig">Default Terms and Conditions (used when a quotation has no terms):</label>
                    <textarea id="defaultTermsConfig" placeholder="Paste default terms here. Save to apply for all new quotations." style="width: 100%; min-height: 120px; padding: 8px; margin-top: 8px; border: 2px solid #ddd; border-radius: 4px; font-family: inherit;"></textarea>
                    <button type="button" class="upload-btn" onclick="saveDefaultTerms()" style="margin-top: 10px; width: 100%;">
                        ðŸ’¾ Save Default Terms
                    </button>
                    <p id="defaultTermsStatus" style="margin-top: 8px; font-size: 12px; color: #666;"></p>
                </div>
                
                <!-- Uploaded Files Management Section -->
                <div class="input-section" id="filesManagementSection" style="margin-top: 30px;">
                    <h2>Uploaded Rate Files</h2>
                    <div id="uploadedFilesList">
                        <p style="text-align: center; color: #999; padding: 20px;">No files uploaded yet.</p>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Input area: Where staff enters data (no heading) -->
        <div class="input-section" id="creationSection">
            <!-- Email content input -->
            <label for="emailContent">Email Content (paste here):</label>
            <textarea 
                id="emailContent" 
                placeholder="Paste email content here... Example: Customer: ABC Company, Project: Office Renovation, Need 50 pipes of 2 inch diameter..."
            ></textarea>
            
            <!-- File upload input -->
            <label for="fileUpload" style="margin-top: 20px;">Or Upload File (PDF/Word/Text):</label>
            <input 
                type="file" 
                id="fileUpload" 
                accept=".pdf,.doc,.docx,.txt"
            >
            
            <!-- Generate button -->
            <button class="generate-btn" onclick="generateQuotation()">
                âœ¨ Generate Quotation
            </button>
        </div>
        
        <!-- Error message area (hidden by default) -->
        <div id="errorMessage" class="error-message"></div>
        
        <!-- Creation: Quotation Display Section (always visible) -->
        <div id="quotationSection" class="quotation-section">
            <h2>Creation</h2>
            <p id="noCreationQuotation" style="text-align: center; color: #999; padding: 20px;">
                Generate a quotation to see it here.
            </p>
            <div id="creationFilesContainer"></div>
            <div id="creationFilesContainer"></div>
            
            <!-- Quotation Header (hidden initially) -->
            <div class="quotation-header" id="creationQuotationHeader" style="display: none;">
                <div class="quote-header-top">
                    <div style="display:flex; align-items:center;">
                        <div class="logo-placeholder">
                            <span id="logoText" style="display: block;">LOGO</span>
                            <img id="logoImg" src="/logo.png" alt="Logo" style="display: none;">
                        </div>
                        <div class="company-info">
                            <h3>DSC PIPES AND TUBES PVT LTD</h3>
                            <p>REGD OFFICE: 7C, 7TH FLOOR, DOSHI TOWERS, NO:156</p>
                            <p>P.H ROAD, KILAPUK, CHENNAI - 600 010</p>
                            <p>EMAIL ID: info@dscpipes.com</p>
                        </div>
                    </div>
                    <div class="quote-title">QUOTATION</div>
                </div>

                <div class="quote-meta">
                    <div>
                        <div class="meta-row"><span>QUOTATION DATE</span><input type="text" id="quotationDate" class="header-editable" style="width: 140px;"></div>
                        <div class="meta-row"><span>KIND ATTN</span><input type="text" id="kindAttn" class="header-editable" style="width: 140px;"></div>
                        <div class="meta-row"><span>PHONE NUMBER</span><input type="text" id="phoneNumber" class="header-editable" style="width: 140px;"></div>
                        <div class="meta-row"><span>MOBILE NUMBER</span><input type="text" id="mobileNumber" class="header-editable" style="width: 140px;"></div>
                    </div>
                    <div>
                        <div class="meta-row"><span>PREPARED BY</span><input type="text" id="preparedBy" class="header-editable" style="width: 140px;"></div>
                        <div class="meta-row"><span>ASSIGNED TO</span><input type="text" id="assignedTo" class="header-editable" style="width: 140px;"></div>
                        <div class="meta-row"><span>CHECKED BY</span><input type="text" id="checkedBy" class="header-editable" style="width: 140px;"></div>
                        <div class="meta-row"><span>QUOTE NUMBER</span><input type="text" id="quoteNumber" data-field="quoteNumber" class="header-editable" style="width: 140px;"></div>
                    </div>
                </div>

                <div class="bill-ship">
                    <div><strong>Bill To</strong><br><input type="text" id="billTo" class="header-editable" style="width: 100%;"></div>
                    <div><strong>Ship To</strong><br><input type="text" id="shipTo" class="header-editable" style="width: 100%;"></div>
                </div>
            </div>
            
            <!-- Quotation Table (hidden initially) -->
            <table id="quotationTable" style="display: none;">
                <thead>
                    <tr>
                        <th style="width: 50px;"></th>
                        <th>S. NO</th>
                        <th>ITEMS AND DESCRIPTION</th>
                        <th><input type="text" value="QTY (Mtrs)" style="width: 100%; border: none; background: transparent; color: white; font-weight: bold;"></th>
                        <th class="col-base-rate">BASE RATE</th>
                        <th class="col-margin">MARGIN %</th>
                        <th><input type="text" value="Rate per Mtr" style="width: 100%; border: none; background: transparent; color: white; font-weight: bold;"></th>
                        <th>AMOUNT</th>
                    </tr>
                </thead>
                <tbody id="quotationTableBody">
                    <!-- Table rows will be inserted here by JavaScript -->
                </tbody>
            </table>
            
            <!-- Grand Total (hidden initially) -->
            <div class="grand-total" id="creationGrandTotal" style="display: none;">
                <span>Total: â‚¹<span id="grandTotal">0.00</span></span>
            </div>

            <hr class="terms-divider" id="termsDivider" style="display: none;">
            <!-- Terms and Conditions -->
            <div class="terms-box" id="termsBox" style="display: none;">
                <h4>TERMS AND CONDITIONS</h4>
                <textarea id="termsText" class="terms-textarea" style="width:100%; padding:6px 0; border:none; border-radius:0; font-family: inherit; font-size: 14px; background: transparent; outline: none;">
1. GST: exclusive and rate of GST is 18% or 9% + 9%
2. TCS: extra
3. Delivery period: will be confirmed at the time of finalisation of order.
4. Inspection: (a) Test certificates will be provided & inspection is mandatory before despatch. (b) No claim will be entertained once material is delivered. (c) Nature of inspection will be visual and dimensional if req (only for seamless) one sample per (H.NO / B.NO) per size can be provided. (d) Cutting charges and testing charges will be extra. Any other specific condition by you or your client / TPI is not acceptable to us
5. Payment: immediate / L/C
6. Special condition: any increase in prices by principle before despatch will be applicable to you
7. Pipe length: will be either 4 to 7 mtrs (SRL) or 9 to 12.5 mtrs (DRL)
8. Price basis: ex-godown
9. Freight charge: extra
10. Make: (a) For ERW/GI: Jindal, Surya Roshini, APL Apollo/Tata/any other ISI make (b) For seamless: MSL/JSL/ISMT/Importer/Rashni/MKK
11. Price validity: 1 day from quotation date
12. Imp condition: (1) After issuing P.O, payment or PDC to be released within 3 days & inspection has to be carried out within next 3 days, otherwise we are not responsible for shortage of material. (2) If any size is not available we may quote near by possible specification or size
13. Pipe end: for ERW / seamless - plain end or bevelled end; for galvanised: SWS (thread end / screwed end) or plain end
                </textarea>
            </div>
            
            <!-- Approve Button (hidden initially) -->
            <button class="approve-btn" id="creationApproveBtn" onclick="approveQuotation()" style="display: none;">
                âœ… Create Quotation
            </button>
        </div>
        
        <!-- Approval Section (shows all approved quotations) -->
        <div id="approvalSection" class="quotation-section">
            <h2>Approval</h2>
            <div style="margin-bottom: 10px;">
                <input
                    type="text"
                    id="approvalSearchInput"
                    placeholder="Search by company, kind attn, or month (e.g., January)"
                    style="width: 100%; padding: 8px 10px; border: 1px solid #ddd; border-radius: 4px;"
                >
            </div>
            <div id="approvedQuotationsContainer">
                <!-- All approved quotations will be displayed here -->
                <p id="noApprovedQuotations" style="text-align: center; color: #999; padding: 20px;">
                    No quotations approved yet. Create and approve a quotation to see it here.
                </p>
            </div>
        </div>

        <!-- AI Response Section -->
        <div id="aiResponseSection" class="quotation-section">
            <h2>AI Response</h2>
            <p style="color: #666; margin-bottom: 10px;">This shows what the AI returned and any errors.</p>
            <div id="aiErrorBox" style="display:none; background:#ffebee; border:1px solid #f44336; color:#c62828; padding:10px; border-radius:4px; margin-bottom:10px;"></div>
            <textarea id="aiRawOutput" style="width:100%; min-height:160px; padding:10px; border:1px solid #ddd; border-radius:4px; font-family: monospace;" placeholder="AI output will appear here..."></textarea>

            <h3 style="margin-top:20px;">Talk to AI</h3>
            <div id="aiChatLog" style="border:1px solid #ddd; border-radius:4px; padding:10px; min-height:80px; background:#fafafa; margin-bottom:10px;"></div>
            <textarea id="aiChatInput" placeholder="Type your question about the AI output..." style="width:100%; min-height:60px; padding:10px; border:1px solid #ddd; border-radius:4px;"></textarea>
            <button type="button" class="upload-btn" onclick="sendAiMessage()" style="margin-top:10px; width:100%;">ðŸ’¬ Ask AI</button>
        </div>
    </div>
    
    <!-- 
        ============================================
        JAVASCRIPT - This makes the page interactive
        ============================================
        JavaScript handles user actions and calculations
    -->
    
    <script>
        /*
            ============================================
            JAVASCRIPT EXPLANATION
            ============================================
            JavaScript is a programming language that runs in the browser.
            It makes web pages interactive and can perform calculations.
            
            Variables store data (like numbers, text, etc.)
            Functions are reusable blocks of code that do specific tasks
        */
        
        /*
            ============================================
            API BASE URL
            ============================================
            Backend server URL - change if your server runs on different port
        */
        // Use current origin when valid (localhost or Vercel); fallback for file:// so fetch works locally
        const origin = window.location.origin;
        const API_BASE_URL = (origin && origin !== 'null' && origin.startsWith('http'))
            ? origin + '/api'
            : 'http://localhost:3000/api';
        let lastAiRawOutput = '';
        
        /*
            ============================================
            SAFE JSON PARSER HELPER FUNCTION
            ============================================
            Safely parses response as JSON, handling both JSON and non-JSON responses
        */
        async function safeJsonParse(response) {
            const contentType = response.headers.get('content-type') || '';
            if (contentType.includes('application/json')) {
                return await response.json();
            } else {
                // Server returned non-JSON (likely an error page)
                const text = await response.text();
                return {
                    error: text || `Server error (Status: ${response.status})`,
                    details: 'Server returned non-JSON response. This usually means the API endpoint is not found or the server is not running.'
                };
            }
        }

        function escapeHtml(text) {
            return String(text || '')
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#39;');
        }

        function sanitizeQuotationForSave(quotation) {
            const q = { ...quotation };
            const fc = (q.fileContent || '').trim();
            if (fc && (fc.startsWith('%PDF') || fc.length > 500000)) {
                q.fileContent = PDF_PLACEHOLDER;
            }
            return q;
        }

        async function saveQuotationToBackend(quotation) {
            try {
                const sanitized = sanitizeQuotationForSave(quotation);
                const response = await fetch(`${API_BASE_URL}/save-quotation`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ quotation: sanitized })
                });
                const result = await safeJsonParse(response);
                if (!response.ok) {
                    throw new Error(result.error || 'Failed to save quotation');
                }
                return true;
            } catch (error) {
                console.error('Error saving quotation to backend:', error);
                alert('Failed to save to server: ' + (error.message || 'Network error'));
                return false;
            }
        }

        const backendSaveTimers = new Map();

        function scheduleQuotationBackendSave(quotation, delay = 1000) {
            if (!quotation || !quotation.id) {
                return;
            }
            const existingTimer = backendSaveTimers.get(quotation.id);
            if (existingTimer) {
                clearTimeout(existingTimer);
            }
            const timeoutId = setTimeout(() => {
                backendSaveTimers.delete(quotation.id);
                saveQuotationToBackend(quotation);
            }, delay);
            backendSaveTimers.set(quotation.id, timeoutId);
        }

        async function loadQuotationsFromBackend() {
            try {
                const response = await fetch(`${API_BASE_URL}/quotations`);
                const result = await safeJsonParse(response);
                if (!response.ok) {
                    throw new Error(result.error || 'Failed to load quotations');
                }
                const quotations = Array.isArray(result.quotations) ? result.quotations : [];
                if (quotations.length > 0) {
                    approvedQuotations = quotations;
                    displayAllApprovedQuotations();
                    return true;
                }
                return false;
            } catch (error) {
                console.error('Error loading quotations from backend:', error);
                return false;
            }
        }

        async function initQuotations() {
            await loadQuotationsFromBackend();
        }

        /*
            ============================================
            UPLOAD STATUS BANNER FUNCTION
            ============================================
            Shows a visible banner for upload results
        */
        function showUploadStatus(message, isError = false) {
            const banner = document.getElementById('uploadStatusBanner');
            if (!banner) {
                return;
            }
            banner.style.display = 'block';
            banner.textContent = message;
            banner.style.backgroundColor = isError ? '#ffebee' : '#e8f5e9';
            banner.style.color = isError ? '#c62828' : '#2e7d32';
            banner.style.border = isError ? '1px solid #f44336' : '1px solid #4CAF50';
        }

        let rateFilePreviewUrls = [];

        function clearRateFilePreviewUrls() {
            if (rateFilePreviewUrls.length === 0) {
                return;
            }
            rateFilePreviewUrls.forEach(url => {
                try {
                    URL.revokeObjectURL(url);
                } catch (error) {
                    console.warn('Failed to revoke object URL:', error);
                }
            });
            rateFilePreviewUrls = [];
        }

        function renderSelectedRateFiles() {
            const fileInput = document.getElementById('rateFileUpload');
            const preview = document.getElementById('rateFilePreview');
            if (!fileInput || !preview) {
                return;
            }
            clearRateFilePreviewUrls();
            const files = Array.from(fileInput.files || []);
            if (files.length === 0) {
                preview.innerHTML = '';
                return;
            }
            const items = files.map(file => {
                const url = URL.createObjectURL(file);
                rateFilePreviewUrls.push(url);
                return `
                    <div style="display:flex; align-items:center; justify-content:space-between; gap:8px; padding:6px 8px; border:1px solid #ddd; border-radius:4px; margin-bottom:6px; background:#fafafa;">
                        <span style="font-size:12px; color:#333;">ðŸ“„ ${file.name}</span>
                        <a href="${url}" target="_blank" rel="noopener noreferrer" style="font-size:12px; color:#1a73e8; text-decoration:none;">View</a>
                    </div>
                `;
            }).join('');
            preview.innerHTML = items;
        }

        function attachRateFilePreviewListener() {
            const fileInput = document.getElementById('rateFileUpload');
            if (!fileInput || fileInput.dataset.previewBound === 'true') {
                return;
            }
            fileInput.addEventListener('change', renderSelectedRateFiles);
            fileInput.dataset.previewBound = 'true';
        }

        /*
            ============================================
            AI RESPONSE DISPLAY FUNCTIONS
            ============================================
        */
        function updateAiResponseOutput(text) {
            lastAiRawOutput = text || '';
            const outputEl = document.getElementById('aiRawOutput');
            if (outputEl) {
                outputEl.value = text || '';
            }
            clearAiError();
        }

        function showAiError(message) {
            const errorEl = document.getElementById('aiErrorBox');
            if (errorEl) {
                errorEl.style.display = 'block';
                errorEl.textContent = message;
            }
        }

        function clearAiError() {
            const errorEl = document.getElementById('aiErrorBox');
            if (errorEl) {
                errorEl.style.display = 'none';
                errorEl.textContent = '';
            }
        }

        function appendChatMessage(role, text) {
            const log = document.getElementById('aiChatLog');
            if (!log) return;
            const msg = document.createElement('div');
            msg.style.marginBottom = '8px';
            msg.innerHTML = `<strong>${role}:</strong> ${text}`;
            log.appendChild(msg);
            log.scrollTop = log.scrollHeight;
        }

        async function sendAiMessage() {
            const input = document.getElementById('aiChatInput');
            const message = input.value.trim();
            if (!message) {
                return;
            }
            appendChatMessage('You', message);
            input.value = '';

            const instructions = document.getElementById('instructionsText')?.value || '';
            try {
                const response = await fetch(`${API_BASE_URL}/ai-chat`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        message,
                        instructions,
                        context: lastAiRawOutput
                    })
                });
                const result = await safeJsonParse(response);
                if (!response.ok) {
                    throw new Error(result.error || 'AI chat failed');
                }
                appendChatMessage('AI', result.reply || '(no response)');
            } catch (error) {
                appendChatMessage('AI', `Error: ${error.message}`);
            }
        }
        
        /*
            ============================================
            UPLOAD RATE FILE FUNCTION
            ============================================
            Uploads PDF rate file to the backend
        */
        async function uploadRateFile() {
            const fileInput = document.getElementById('rateFileUpload');
            const files = fileInput.files;
            const statusEl = document.getElementById('rateFileStatus');
            
            if (!files || files.length === 0) {
                statusEl.textContent = 'Please select at least one file first';
                statusEl.style.color = '#f44336';
                showUploadStatus('Please select at least one file first.', true);
                return;
            }
            
            // Validate files before uploading
            const validFiles = [];
            const invalidFiles = [];
            
            for (let i = 0; i < files.length; i++) {
                const file = files[i];
                const errors = [];
                
                // Check file type
                const validExtensions = ['.xlsx', '.xls', '.pdf'];
                const lastDotIndex = file.name.lastIndexOf('.');
                let fileExt = '';
                
                if (lastDotIndex > 0 && lastDotIndex < file.name.length - 1) {
                    fileExt = file.name.toLowerCase().substring(lastDotIndex);
                }
                
                if (!fileExt || !validExtensions.includes(fileExt)) {
                    errors.push(`Invalid file type${fileExt ? ' (' + fileExt + ')' : ' (no extension)'}. Only .xlsx, .xls, and .pdf files are allowed.`);
                }
                
                // Check file size (10MB limit)
                const maxSize = 10 * 1024 * 1024; // 10MB
                if (file.size > maxSize) {
                    errors.push(`File too large (${(file.size / 1024 / 1024).toFixed(2)}MB). Maximum size is 10MB.`);
                }
                
                if (errors.length > 0) {
                    invalidFiles.push({ name: file.name, errors: errors });
                } else {
                    validFiles.push(file);
                }
            }
            
            // Show errors for invalid files
            if (invalidFiles.length > 0) {
                let errorMsg = 'Cannot upload:\n';
                invalidFiles.forEach(item => {
                    errorMsg += `\n${item.name}:\n`;
                    item.errors.forEach(err => errorMsg += `  - ${err}\n`);
                });
                alert(errorMsg);
                statusEl.textContent = `${invalidFiles.length} file(s) have errors. See alert for details.`;
                statusEl.style.color = '#f44336';
                showUploadStatus(`${invalidFiles.length} file(s) have errors. See alert for details.`, true);
                
                // If no valid files, stop here
                if (validFiles.length === 0) {
                    return;
                }
            }
            
            // If no valid files after validation, stop
            if (validFiles.length === 0) {
                return;
            }
            
            // Upload only valid files
            const formData = new FormData();
            for (let i = 0; i < validFiles.length; i++) {
                formData.append('rateFiles', validFiles[i]);
                console.log(`Adding file to upload: ${validFiles[i].name} (${validFiles[i].size} bytes)`);
            }
            
            try {
                statusEl.textContent = `Uploading ${validFiles.length} file(s)...`;
                statusEl.style.color = '#666';
                showUploadStatus(`Uploading ${validFiles.length} file(s)...`);
                
                console.log(`Uploading ${validFiles.length} file(s) to ${API_BASE_URL}/upload-rates`);
                
                const response = await fetch(`${API_BASE_URL}/upload-rates`, {
                    method: 'POST',
                    body: formData
                });
                
                console.log('Upload response status:', response.status);
                
                // Handle both JSON and non-JSON responses
                const result = await safeJsonParse(response);
                
                if (response.ok) {
                    let successMsg = `âœ“ Uploaded ${validFiles.length} file(s)`;
                    if (invalidFiles.length > 0) {
                        successMsg += ` (${invalidFiles.length} file(s) skipped due to errors)`;
                    }
                    if (result.errors && result.errors.length > 0) {
                        successMsg += `\nServer errors: ${result.errors.map(e => e.filename + ': ' + e.error).join(', ')}`;
                    }
                    statusEl.textContent = successMsg;
                    statusEl.style.color = '#4CAF50';
                    showUploadStatus(successMsg);
                    fileInput.value = '';
                    renderSelectedRateFiles();
                    checkCurrentFiles(); // Refresh status
                    loadUploadedFiles(); // Refresh file list
                } else {
                    let errorMsg = `Error: ${result.error || 'Upload failed'}`;
                    if (result.details) {
                        errorMsg += `\nDetails: ${result.details}`;
                    }
                    if (result.errors && result.errors.length > 0) {
                        errorMsg += `\nFile errors:\n`;
                        result.errors.forEach(err => {
                            errorMsg += `  - ${err.filename}: ${err.error}\n`;
                        });
                    }
                    statusEl.textContent = errorMsg;
                    statusEl.style.color = '#f44336';
                    showUploadStatus(errorMsg, true);
                    console.error('Upload failed:', result);
                }
            } catch (error) {
                let errorMsg = `Error: ${error.message}`;
                if (error.message.includes('Failed to fetch') || error.message.includes('NetworkError')) {
                    errorMsg = 'Cannot connect to server. Make sure the server is running (npm start).';
                }
                statusEl.textContent = errorMsg;
                statusEl.style.color = '#f44336';
                showUploadStatus(errorMsg, true);
                console.error('Upload error:', error);
                alert(`Upload failed: ${errorMsg}\n\nCheck the browser console (F12) for more details.`);
            }
        }
        
        /*
            ============================================
            SAVE INSTRUCTIONS FUNCTION
            ============================================
            Saves AI instructions to server (shared across all devices)
        */
        async function saveInstructions() {
            const instructionsText = document.getElementById('instructionsText').value.trim();
            const statusEl = document.getElementById('instructionsStatus');
            
            if (!instructionsText) {
                statusEl.textContent = 'Please enter instructions first';
                statusEl.style.color = '#f44336';
                return;
            }
            
            try {
                statusEl.textContent = 'Saving...';
                statusEl.style.color = '#666';
                
                // Save to server (shared across all devices)
                const response = await fetch(`${API_BASE_URL}/save-instructions`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ instructions: instructionsText })
                });
                
                const result = await safeJsonParse(response);
                
                if (response.ok) {
                    statusEl.textContent = 'âœ“ Instructions saved (shared with all devices)';
                    statusEl.style.color = '#4CAF50';
                } else {
                    throw new Error(result.error || 'Failed to save instructions');
                }
            } catch (error) {
                statusEl.textContent = `Error: ${error.message}`;
                statusEl.style.color = '#f44336';
                console.error('Error saving instructions:', error);
            }
        }
        
        /*
            ============================================
            LOAD INSTRUCTIONS FUNCTION
            ============================================
            Loads saved instructions from server (shared across all devices)
        */
        async function loadInstructions() {
            try {
                // Try to load from server first (shared across devices)
                const response = await fetch(`${API_BASE_URL}/get-instructions`);
                const result = await safeJsonParse(response);
                
                if (response.ok && result.hasFile && result.content) {
                    document.getElementById('instructionsText').value = result.content;
                    const statusEl = document.getElementById('instructionsStatus');
                    if (statusEl) {
                        statusEl.textContent = 'âœ“ Instructions loaded from server';
                        statusEl.style.color = '#4CAF50';
                    }
                } else {
                    const statusEl = document.getElementById('instructionsStatus');
                    if (statusEl) {
                        statusEl.textContent = 'No instructions found on server';
                        statusEl.style.color = '#999';
                    }
                }
            } catch (error) {
                console.error('Error loading instructions from server:', error);
                const statusEl = document.getElementById('instructionsStatus');
                if (statusEl) {
                    statusEl.textContent = 'Error loading instructions from server';
                    statusEl.style.color = '#f44336';
                }
            }
        }
        
        /*
            ============================================
            SAVE DEFAULT TERMS FUNCTION
            ============================================
            Saves default terms and conditions to server (shared across all devices)
        */
        async function saveDefaultTerms() {
            const textarea = document.getElementById('defaultTermsConfig');
            const statusEl = document.getElementById('defaultTermsStatus');
            if (!textarea || !statusEl) return;
            const value = textarea.value;
            try {
                statusEl.textContent = 'Saving...';
                statusEl.style.color = '#666';
                const response = await fetch(`${API_BASE_URL}/save-default-terms`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ defaultTerms: value })
                });
                const result = await safeJsonParse(response);
                if (response.ok) {
                    defaultTermsText = value;
                    statusEl.textContent = 'âœ“ Default terms saved (shared with all devices)';
                    statusEl.style.color = '#4CAF50';
                } else {
                    throw new Error(result.error || 'Failed to save default terms');
                }
            } catch (error) {
                statusEl.textContent = `Error: ${error.message}`;
                statusEl.style.color = '#f44336';
                console.error('Error saving default terms:', error);
            }
        }
        
        /*
            ============================================
            LOAD DEFAULT TERMS FUNCTION
            ============================================
            Loads default terms from server and sets global defaultTermsText
        */
        async function loadDefaultTerms() {
            const textarea = document.getElementById('defaultTermsConfig');
            const statusEl = document.getElementById('defaultTermsStatus');
            const fallback = document.getElementById('termsText') ? document.getElementById('termsText').value : '';
            try {
                const response = await fetch(`${API_BASE_URL}/get-default-terms`);
                const result = await safeJsonParse(response);
                if (response.ok && result.hasFile && result.content !== undefined) {
                    defaultTermsText = result.content || fallback;
                    if (textarea) textarea.value = result.content || '';
                    if (statusEl) {
                        statusEl.textContent = 'âœ“ Default terms loaded from server';
                        statusEl.style.color = '#4CAF50';
                    }
                } else {
                    defaultTermsText = fallback;
                    if (textarea) textarea.value = fallback;
                    if (statusEl) {
                        statusEl.textContent = 'Using in-page terms as default (save here to set server default)';
                        statusEl.style.color = '#999';
                    }
                }
            } catch (error) {
                console.error('Error loading default terms:', error);
                defaultTermsText = fallback;
                if (textarea) textarea.value = fallback;
            }
        }
        
        /*
            ============================================
            DELETE RATE FILE FUNCTION
            ============================================
            Deletes an uploaded rate file
        */
        async function deleteRateFile(filename) {
            if (!confirm(`Are you sure you want to delete "${filename}"?`)) {
                return;
            }
            
            try {
                const response = await fetch(`${API_BASE_URL}/delete-rate-file`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ filename: filename })
                });
                
                const result = await safeJsonParse(response);
                
                if (response.ok) {
                    // Refresh the file list
                    loadUploadedFiles();
                } else {
                    alert(`Error: ${result.error}`);
                }
            } catch (error) {
                alert(`Error: ${error.message}`);
            }
        }
        
        /*
            ============================================
            LOAD UPLOADED FILES FUNCTION
            ============================================
            Displays all uploaded rate files with delete option
        */
        async function loadUploadedFiles() {
            try {
                const response = await fetch(`${API_BASE_URL}/current-rates`);
                const data = await safeJsonParse(response);
                
                const filesListDiv = document.getElementById('uploadedFilesList');
                
                if (!data.hasFiles || data.count === 0) {
                    filesListDiv.innerHTML = '<p style="text-align: center; color: #999; padding: 20px;">No files uploaded yet.</p>';
                    return;
                }
                
                let filesHTML = '<div style="display: grid; gap: 10px;">';
                data.filenames.forEach((filename, index) => {
                    const viewUrl = `${API_BASE_URL}/view-rate-file?filename=${encodeURIComponent(filename)}`;
                    filesHTML += `
                        <div style="display: flex; justify-content: space-between; align-items: center; padding: 10px; background-color: #f5f5f5; border-radius: 4px; border: 1px solid #ddd;">
                            <span>ðŸ“„ ${filename}</span>
                            <div style="display:flex; gap:8px; align-items:center;">
                                <a href="${viewUrl}" target="_blank" rel="noopener noreferrer" style="background-color: #1a73e8; color: white; border: none; padding: 5px 12px; border-radius: 4px; cursor: pointer; font-size: 12px; text-decoration: none;">View</a>
                                <button onclick="deleteRateFile('${filename}')" style="background-color: #f44336; color: white; border: none; padding: 5px 15px; border-radius: 4px; cursor: pointer; font-size: 12px;">Delete</button>
                            </div>
                        </div>
                    `;
                });
                filesHTML += '</div>';
                
                filesListDiv.innerHTML = filesHTML;
            } catch (error) {
                console.error('Error loading files:', error);
            }
        }
        
        /*
            ============================================
            CHECK CURRENT FILES FUNCTION
            ============================================
            Checks which rate file and instructions are currently active
        */
        async function checkCurrentFiles() {
            try {
                // Check rate files
                const rateResponse = await fetch(`${API_BASE_URL}/current-rates`);
                const rateData = await rateResponse.json();
                
                if (rateData.hasFiles && rateData.count > 0) {
                    const statusEl = document.getElementById('rateFileStatus');
                    statusEl.textContent = `Current: ${rateData.count} file(s) - ${rateData.filenames.slice(0, 2).join(', ')}${rateData.count > 2 ? '...' : ''}`;
                    statusEl.style.color = '#4CAF50';
                }
                
                // Load instructions from server
                loadInstructions();
            } catch (error) {
                console.error('Error checking files:', error);
            }
        }
        
        /*
            ============================================
            AI EXTRACTION FUNCTION (REAL AI)
            ============================================
            Calls the backend API to extract quotation data using OpenAI
        */
        async function extractQuotationWithAI(emailContent, fileContent) {
            /*
                This function calls the backend API which uses OpenAI to extract quotation data.
                
                Parameters:
                - emailContent: Text from the email textarea
                - fileContent: Content from uploaded file (if any)
                
                Returns: Promise that resolves to an object with customer info and line items
            */
            
            // Get instructions from the current textarea
            const instructions = document.getElementById('instructionsText')?.value || '';
            
            if (!instructions || instructions.trim() === '') {
                throw new Error('No instructions provided. Please enter and save instructions first.');
            }
            
            try {
                const response = await fetch(`${API_BASE_URL}/generate-quotation`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        emailContent: emailContent,
                        fileContent: fileContent,
                        instructions: instructions
                    })
                });
                
                const quotationData = await safeJsonParse(response);
                
                if (!response.ok) {
                    const errorMessage = quotationData.error || 'Failed to generate quotation';
                    const errorDetails = quotationData.details ? ` | Details: ${quotationData.details}` : '';
                    showAiError(`${errorMessage}${errorDetails}`);
                    throw new Error(`${errorMessage}${errorDetails}`);
                }
                const aiRaw = quotationData?._ai?.raw || JSON.stringify(quotationData, null, 2);
                updateAiResponseOutput(aiRaw);
                return quotationData;
                
            } catch (error) {
                console.error('Error calling AI API:', error);
                showAiError(error.message);
                throw error;
            }
        }

        async function extractQuotationWithAIFile(emailContent, file) {
            const instructions = document.getElementById('instructionsText')?.value || '';
            
            if (!instructions || instructions.trim() === '') {
                throw new Error('No instructions provided. Please enter and save instructions first.');
            }
            
            const formData = new FormData();
            if (emailContent) {
                formData.append('emailContent', emailContent);
            }
            formData.append('instructions', instructions);
            if (file) {
                formData.append('enquiryFile', file);
            }
            
            try {
                const response = await fetch(`${API_BASE_URL}/generate-quotation-file`, {
                    method: 'POST',
                    body: formData
                });
                const quotationData = await safeJsonParse(response);
                
                if (!response.ok) {
                    const errorMessage = quotationData.error || 'Failed to generate quotation';
                    const errorDetails = quotationData.details ? ` | Details: ${quotationData.details}` : '';
                    showAiError(`${errorMessage}${errorDetails}`);
                    throw new Error(`${errorMessage}${errorDetails}`);
                }
                const aiRaw = quotationData?._ai?.raw || JSON.stringify(quotationData, null, 2);
                updateAiResponseOutput(aiRaw);
                return quotationData;
                
            } catch (error) {
                console.error('Error calling AI API:', error);
                showAiError(error.message);
                throw error;
            }
        }
        
        /*
            ============================================
            MOCK AI FUNCTION (FALLBACK)
            ============================================
            This function is kept as a fallback if backend is not available.
        */
        function mockAIExtraction(emailContent, fileContent) {
            /*
                This function takes email content and file content as input
                and returns structured data as if an AI analyzed it.
                
                Parameters:
                - emailContent: Text from the email textarea
                - fileContent: Content from uploaded file (if any)
                
                Returns: An object with customer info and line items
            */
            
            // For now, we'll use sample data regardless of input
            // In a real app, AI would analyze the content and extract actual values
            
            // Get today's date in a readable format
            const today = new Date();
            const dateString = today.toLocaleDateString('en-US', { 
                year: 'numeric', 
                month: 'long', 
                day: 'numeric' 
            });
            
            // Return structured data with sample values
            return {
                customerName: "ABC Construction Company",
                projectName: "Office Building Renovation",
                contactDetails: "john.smith@abcconstruction.com | Phone: (555) 123-4567",
                quotationDate: dateString,
                lineItems: [
                    {
                        originalDescription: "2 inch diameter PVC pipe, 10 feet length",
                        identifiedPipeType: "PVC Pipe - 2 inch",
                        quantity: "50",
                        unitRate: "2500.00",
                        marginPercent: "15",
                        finalRate: "2875.00",
                        lineTotal: "143750.00"
                    },
                    {
                        originalDescription: "2 inch diameter PVC pipe, 8 feet length",
                        identifiedPipeType: "PVC Pipe - 2 inch",
                        quantity: "30",
                        unitRate: "2000.00",
                        marginPercent: "15",
                        finalRate: "2300.00",
                        lineTotal: "69000.00"
                    },
                    {
                        originalDescription: "4 inch diameter steel pipe, standard grade",
                        identifiedPipeType: "Steel Pipe - 4 inch",
                        quantity: "30",
                        unitRate: "8500.00",
                        marginPercent: "20",
                        finalRate: "10200.00",
                        lineTotal: "306000.00"
                    },
                    {
                        originalDescription: "4 inch diameter steel pipe, heavy duty",
                        identifiedPipeType: "Steel Pipe - 4 inch",
                        quantity: "20",
                        unitRate: "9500.00",
                        marginPercent: "20",
                        finalRate: "11400.00",
                        lineTotal: "228000.00"
                    },
                    {
                        originalDescription: "1.5 inch copper pipe for plumbing",
                        identifiedPipeType: "Copper Pipe - 1.5 inch",
                        quantity: "75",
                        unitRate: "4500.00",
                        marginPercent: "18",
                        finalRate: "5310.00",
                        lineTotal: "398250.00"
                    },
                    {
                        originalDescription: "3 inch HDPE pipe, industrial grade",
                        identifiedPipeType: "HDPE Pipe - 3 inch",
                        quantity: "40",
                        unitRate: "6000.00",
                        marginPercent: "12",
                        finalRate: "6720.00",
                        lineTotal: "268800.00"
                    }
                ]
            };
        }
        
        /*
            ============================================
            FILE READING FUNCTION
            ============================================
            This function reads the content of an uploaded file.
            For text files, it reads the text directly.
            For PDF/Word files, it would need special libraries (not included here).
        */
        function readFileContent(file) {
            /*
                This function reads a file and returns its content as text.
                
                Parameter:
                - file: The file object from the file input
                
                Returns: A Promise that resolves with the file content
            */
            
            return new Promise((resolve, reject) => {
                // Check if file exists
                if (!file) {
                    resolve(""); // Return empty string if no file
                    return;
                }
                
                // Create a FileReader object (built into browsers)
                const reader = new FileReader();
                
                // When file is read successfully
                reader.onload = function(event) {
                    resolve(event.target.result); // Return the file content
                };
                
                // If there's an error reading the file
                reader.onerror = function() {
                    reject(new Error("Failed to read file"));
                };
                
                // Read the file as text
                // Note: For PDF/Word files, this will show binary data
                // In a real app, you'd need special libraries to parse PDF/Word
                reader.readAsText(file);
            });
        }
        
        /*
            ============================================
            MAIN FUNCTION: Generate Quotation
            ============================================
            This is the main function that runs when the button is clicked.
            It coordinates all the steps to generate a quotation.
        */
        function getInputsForQuotation() {
            const emailContent = document.getElementById('emailContent').value;
            const fileInput = document.getElementById('fileUpload');
            const file = fileInput.files[0];
            return { emailContent, fileInput, file };
        }

        const PDF_PLACEHOLDER = '(PDF uploaded - content extracted by AI)';

        function isPdfFile(file) {
            if (!file) return false;
            const type = (file.type || '').toLowerCase();
            const name = (file.name || '').toLowerCase();
            return type === 'application/pdf' || name.endsWith('.pdf');
        }

        async function readUploadedFileContent(file) {
            let fileContent = "";
            if (file) {
                if (isPdfFile(file)) {
                    fileContent = PDF_PLACEHOLDER;
                } else {
                    fileContent = await readFileContent(file);
                }
            }
            return fileContent;
        }

        function ensureInputProvided(emailContent, fileContent) {
            if (!emailContent.trim() && !fileContent.trim()) {
                showError("Please provide either email content or upload a file.");
                return false;
            }
            return true;
        }

        function showAiProcessingMessage() {
            showError("Processing with AI... Please wait.");
        }

        function clearErrorMessage() {
            hideError();
        }

        function getCreationFilesContainer() {
            return document.getElementById('creationFilesContainer');
        }

        function buildCreationFolderTitle(emailContent, file) {
            const trimmed = (emailContent || '').trim();
            if (file && file.name) {
                return `File: ${file.name}`;
            }
            if (trimmed) {
                const snippet = trimmed.replace(/\s+/g, ' ').slice(0, 40);
                return `Email: ${snippet}${trimmed.length > 40 ? 'â€¦' : ''}`;
            }
            return 'Email Quotation';
        }

        function createCreationFolderEntry(emailContent, file) {
            const container = getCreationFilesContainer();
            if (!container) {
                return null;
            }
            const entryId = `creation-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;
            const title = buildCreationFolderTitle(emailContent, file);

            const wrapper = document.createElement('div');
            wrapper.className = 'quotation-folder';
            wrapper.id = `folder-${entryId}`;
            wrapper.innerHTML = `
                <div class="quotation-folder-header" onclick="toggleQuotationFolder('${entryId}')">
                    <span>
                        <span class="folder-icon">ðŸ“</span>
                        ${escapeHtml(title)}
                    </span>
                    <span style="display: inline-flex; align-items: center; gap: 6px;">
                        <span id="creation-loading-${entryId}" class="creation-loading-icon" aria-label="Processing" style="color:#666; font-size:12px;">â³</span>
                        <span class="folder-toggle-icon">â–¶</span>
                    </span>
                </div>
                <div class="quotation-folder-content" id="folder-content-${entryId}">
                </div>
            `;

            container.prepend(wrapper);
            updateCreationEmptyMessage();
            return entryId;
        }

        function buildCreationFolderContentFromDisplay(entryId) {
            const header = document.getElementById('creationQuotationHeader');
            const table = document.getElementById('quotationTable');
            const grandTotalText = document.getElementById('grandTotal')?.textContent || '';
            const termsValue = document.getElementById('termsText')?.value || '';
            const headerClone = header ? cloneQuotationHeaderWithValues(header) : null;
            const tableClone = table ? cloneQuotationTableWithValues(table) : null;
            const termsText = termsValue || defaultTermsText || '';
            if (headerClone) {
                stripIdsFromClone(headerClone);
            }
            if (tableClone) {
                stripIdsFromClone(tableClone);
            }

            return `
                ${headerClone ? headerClone.outerHTML : ''}
                ${tableClone ? tableClone.outerHTML : ''}
                <div class="grand-total">
                    <span>Total: â‚¹${grandTotalText}</span>
                </div>
                ${buildEditableTermsBoxHtml(termsText)}
                <button class="approve-btn" onclick="approveQuotationFromCreationFolder('${entryId}')">
                    âœ… Create Quotation
                </button>
            `;
        }

        function buildEditableTermsBoxHtml(termsText) {
            if (!termsText) {
                return '';
            }
            return `
                <hr class="terms-divider">
                <div class="terms-box">
                    <h4>TERMS AND CONDITIONS</h4>
                    <textarea class="terms-textarea" data-field="termsText" style="width:100%; padding:6px 0; border:none; border-radius:0; font-family: inherit; font-size: 14px; background: transparent; outline: none;">${escapeHtml(termsText)}</textarea>
                </div>
            `;
        }

        function stripIdsFromClone(cloneRoot) {
            if (!cloneRoot) {
                return;
            }
            const nodesWithId = cloneRoot.querySelectorAll ? cloneRoot.querySelectorAll('[id]') : [];
            nodesWithId.forEach(function(node) {
                const id = node.getAttribute('id');
                if (id && !node.getAttribute('data-field')) {
                    node.setAttribute('data-field', id);
                }
                node.removeAttribute('id');
            });
            if (cloneRoot.getAttribute && cloneRoot.getAttribute('id')) {
                cloneRoot.removeAttribute('id');
            }
        }

        function buildCreationFolderContentFromData(quotationData) {
            if (!quotationData) {
                return '';
            }
            const termsText = quotationData.termsText || defaultTermsText || '';
            return `
                ${quotationData.headerHTML || ''}
                ${quotationData.tableHTML || ''}
                <div class="grand-total">
                    <span>Total: â‚¹${quotationData.grandTotal || ''}</span>
                </div>
                ${buildEditableTermsBoxHtml(termsText)}
            `;
        }

        async function finalizeCreationFolderEntry(entryId) {
            const content = document.getElementById(`folder-content-${entryId}`);
            if (!content) {
                return;
            }
            content.innerHTML = buildCreationFolderContentFromDisplay(entryId);
            const loading = document.getElementById(`creation-loading-${entryId}`);
            if (loading) {
                loading.remove();
            }
            attachCreationFolderRowButtons(entryId);
            attachCreationFolderCalculationListeners(entryId);
            const quoteInput = content.querySelector('[data-field="quoteNumber"]');
            if (quoteInput && !quoteInput.value.trim()) {
                try {
                    quoteInput.value = await consumeNextQuoteNumber();
                } catch (e) {
                    console.error('Failed to set quote number in creation folder:', e);
                }
            }
        }

        function removeCreationFolderEntry(entryId) {
            const wrapper = document.getElementById(`folder-${entryId}`);
            if (wrapper) {
                wrapper.remove();
            }
            const loading = document.getElementById(`creation-loading-${entryId}`);
            if (loading) {
                loading.remove();
            }
            delete creationFolderState[entryId];
            updateCreationEmptyMessage();
            updateCreationContainerScrollLimit();
        }

        function markCreationFolderEntryError(entryId, message) {
            const content = document.getElementById(`folder-content-${entryId}`);
            if (!content) {
                return;
            }
            content.innerHTML = `
                <div style="padding: 8px 0; color: #c62828; display: flex; align-items: center; gap: 8px;">
                    <span>âš ï¸</span>
                    <span>${escapeHtml(message)}</span>
                </div>
            `;
            const loading = document.getElementById(`creation-loading-${entryId}`);
            if (loading) {
                loading.remove();
            }
        }

        function updateCreationContainerScrollLimit() {
            const container = getCreationFilesContainer();
            if (!container) {
                return;
            }
            const folders = Array.from(container.querySelectorAll('.quotation-folder'));
            if (folders.length <= 5) {
                container.style.maxHeight = '';
                container.style.overflowY = '';
                return;
            }
            let totalHeight = 0;
            for (let i = 0; i < Math.min(5, folders.length); i += 1) {
                totalHeight += folders[i].getBoundingClientRect().height;
            }
            totalHeight += 10;
            container.style.maxHeight = `${Math.ceil(totalHeight)}px`;
            container.style.overflowY = 'auto';
        }

        function updateCreationEmptyMessage() {
            const noCreationMsg = document.getElementById('noCreationQuotation');
            const container = getCreationFilesContainer();
            if (!noCreationMsg || !container) {
                return;
            }
            const hasFolders = container.querySelectorAll('.quotation-folder').length > 0;
            noCreationMsg.style.display = hasFolders ? 'none' : 'block';
        }

        function sanitizeEmailHtmlTable(html) {
            if (!html) {
                return '';
            }
            const wrapper = document.createElement('div');
            wrapper.innerHTML = html;
            const table = wrapper.querySelector('table');
            if (!table) {
                return '';
            }
            const allowedTags = new Set(['TABLE', 'THEAD', 'TBODY', 'TFOOT', 'TR', 'TH', 'TD']);
            table.querySelectorAll('*').forEach(node => {
                if (!allowedTags.has(node.tagName)) {
                    const text = node.textContent || '';
                    const textNode = document.createTextNode(text);
                    node.replaceWith(textNode);
                    return;
                }
                node.removeAttribute('style');
            });
            table.removeAttribute('style');
            return table.outerHTML;
        }

        function sanitizeEmailHtmlForPreview(html) {
            if (!html) {
                return '';
            }
            const wrapper = document.createElement('div');
            wrapper.innerHTML = html;
            wrapper.querySelectorAll('script, style, link, meta').forEach(node => node.remove());
            const allowedTags = new Set([
                'DIV', 'P', 'BR', 'SPAN', 'STRONG', 'B', 'EM', 'I', 'U',
                'TABLE', 'THEAD', 'TBODY', 'TFOOT', 'TR', 'TH', 'TD',
                'UL', 'OL', 'LI'
            ]);
            wrapper.querySelectorAll('*').forEach(node => {
                if (!allowedTags.has(node.tagName)) {
                    const text = node.textContent || '';
                    node.replaceWith(document.createTextNode(text));
                    return;
                }
                Array.from(node.attributes).forEach(attr => {
                    if (attr.name.toLowerCase().startsWith('on')) {
                        node.removeAttribute(attr.name);
                    }
                });
            });
            return wrapper.innerHTML;
        }

        function buildEmailContentPreviewHTML(quotation) {
            const htmlPreview = sanitizeEmailHtmlForPreview(quotation.emailContentHtml);
            if (htmlPreview) {
                return `<div class="email-html-preview">${htmlPreview}</div>`;
            }
            const textTable = buildTableFromTabbedText(quotation.emailContent || '');
            if (textTable) {
                return `<div class="email-table-preview">${textTable}</div>`;
            }
            return `<div style="white-space: pre-wrap; font-size: 12px; background:#fafafa; border:1px solid #eee; padding:8px; border-radius:4px;">${escapeHtml(quotation.emailContent || '')}</div>`;
        }

        function extractSurroundingTextFromHtml(html) {
            if (!html) {
                return { before: '', after: '' };
            }
            const wrapper = document.createElement('div');
            wrapper.innerHTML = html;
            const tables = wrapper.querySelectorAll('table');
            if (!tables.length) {
                const text = wrapper.textContent || '';
                return { before: text.replace(/\s+\n/g, '\n').trim(), after: '' };
            }
            const firstTable = tables[0];
            const beforeWrapper = document.createElement('div');
            const afterWrapper = document.createElement('div');
            let passedTable = false;
            Array.from(wrapper.childNodes).forEach(node => {
                if (node === firstTable) {
                    passedTable = true;
                    return;
                }
                if (!passedTable) {
                    beforeWrapper.appendChild(node.cloneNode(true));
                } else {
                    afterWrapper.appendChild(node.cloneNode(true));
                }
            });
            const beforeText = (beforeWrapper.textContent || '').replace(/\s+\n/g, '\n').trim();
            const afterText = (afterWrapper.textContent || '').replace(/\s+\n/g, '\n').trim();
            return { before: beforeText, after: afterText };
        }

        function buildTableFromTabbedText(text) {
            const raw = String(text || '').trim();
            if (!raw) {
                return '';
            }
            if (!raw.includes('\t')) {
                return '';
            }
            const rows = raw.split(/\r?\n/).filter(line => line.trim());
            if (rows.length < 2) {
                return '';
            }
            const cells = rows.map(row => row.split('\t'));
            const maxCols = Math.max(...cells.map(row => row.length));
            const normalized = cells.map(row => {
                const filled = row.slice();
                while (filled.length < maxCols) {
                    filled.push('');
                }
                return filled;
            });
            const header = normalized[0];
            const bodyRows = normalized.slice(1);
            const headerHtml = header.map(cell => `<th>${escapeHtml(cell)}</th>`).join('');
            const bodyHtml = bodyRows.map(row => {
                const cols = row.map(cell => `<td>${escapeHtml(cell)}</td>`).join('');
                return `<tr>${cols}</tr>`;
            }).join('');
            return `<table><thead><tr>${headerHtml}</tr></thead><tbody>${bodyHtml}</tbody></table>`;
        }

        function attachEmailPasteListener() {
            const emailInput = document.getElementById('emailContent');
            if (!emailInput || emailInput.dataset.pasteBound === 'true') {
                return;
            }
            emailInput.addEventListener('paste', (event) => {
                const html = event.clipboardData ? event.clipboardData.getData('text/html') : '';
                lastEmailHtmlContent = html || '';
            });
            emailInput.dataset.pasteBound = 'true';
        }

        function formatQuoteNumber(numberValue) {
            return `DSC-${numberValue}`;
        }

        async function consumeNextQuoteNumber() {
            const response = await fetch(`${API_BASE_URL}/next-quote-number`);
            const result = await safeJsonParse(response);
            if (!response.ok) {
                throw new Error(result.error || 'Failed to fetch quote number');
            }
            return formatQuoteNumber(result.value);
        }

        async function fetchQuotationData(emailContent, fileContent, file) {
            if (file) {
                return await extractQuotationWithAIFile(emailContent, file);
            }
            return await extractQuotationWithAI(emailContent, fileContent);
        }

        function renderQuotation(quotationData) {
            displayQuotation(quotationData);
        }

        async function generateQuotation() {
            /*
                async function means this function can wait for things to complete
                (like reading a file) before continuing
            */
            let creationFolderId = null;
            try {
                // Step 1: Get email content from textarea
                const { emailContent, fileInput, file } = getInputsForQuotation();
                
                // Step 3: Read file content (if file was uploaded)
            let fileContent = await readUploadedFileContent(file);
            lastEmailContent = emailContent;
            lastFileContent = fileContent;
                
                // Step 4: Check if at least one input was provided
                if (!ensureInputProvided(emailContent, fileContent)) {
                    return; // Stop here if no input
                }
                const emailInput = document.getElementById('emailContent');
                if (emailInput) {
                    emailInput.value = '';
                }
                
                // Hide any previous error messages
                clearErrorMessage();
                creationFolderId = createCreationFolderEntry(emailContent, file);
                if (creationFolderId) {
                    creationFolderState[creationFolderId] = {
                        emailContent: emailContent || '',
                        emailContentHtml: lastEmailHtmlContent || '',
                        fileContent: fileContent || ''
                    };
                }
                
                // Step 5: Call AI API to extract data
                const quotationData = await fetchQuotationData(emailContent, fileContent, file);

                // Step 6: Display the quotation
                renderQuotation(quotationData);
                if (creationFolderId) {
                    await finalizeCreationFolderEntry(creationFolderId);
                    updateCreationContainerScrollLimit();
                }
                
            } catch (error) {
                // If something goes wrong, show error message
                showError("An error occurred: " + error.message);
                if (creationFolderId) {
                    markCreationFolderEntryError(creationFolderId, error.message || 'Failed to generate quotation.');
                    updateCreationContainerScrollLimit();
                }
            } finally {
                if (creationFolderId) {
                    clearCreationSection();
                    updateCreationEmptyMessage();
                }
            }
        }
        
        /*
            ============================================
            DISPLAY QUOTATION FUNCTION
            ============================================
            This function takes the quotation data and displays it on the page.
            Groups items by pipe type and makes all fields editable.
        */
        function populateQuotationHeader(data) {
            // Step 1: Fill in the header information (make editable)
            document.getElementById('quotationDate').value = data.quotationDate;
            document.getElementById('billTo').value = data.projectName || '';
            document.getElementById('shipTo').value = data.shipTo || '';
            document.getElementById('kindAttn').value = data.customerName || '';
        }

        function getQuotationTableBody() {
            // Step 2: Get the table body element (where rows will be added)
            return document.getElementById('quotationTableBody');
        }

        function clearQuotationTableBody(tableBody) {
            // Step 3: Clear any existing rows
            tableBody.innerHTML = "";
        }

        function groupLineItemsByPipeType(lineItems) {
            // Step 4: Group line items by pipe type
            const groupedItems = {};
            lineItems.forEach(function(item) {
                const pipeType = item.identifiedPipeType;
                if (!groupedItems[pipeType]) {
                    groupedItems[pipeType] = [];
                }
                groupedItems[pipeType].push(item);
            });
            return groupedItems;
        }

        function initializeGrandTotal() {
            // Step 5: Calculate grand total
            return 0;
        }

        // Helper: get standardized header label based on pipe type
        function getPipeHeaderLabel(pipeType) {
            const value = (pipeType || '').toLowerCase();
            if (value.includes('seamless')) {
                return 'CS Seamless Pipe as per ASTM 106 Gr. B';
            }
            if (value.includes('gi') || value.includes('galvanized')) {
                return 'MS GI Pipe as per IS 1239/ 3589';
            }
            if (value.includes('erw')) {
                return 'MS ERW Pipe as per IS 1239/ 3589';
            }
            return pipeType || '';
        }

        function normalizeFractionText(text) {
            if (!text) {
                return text;
            }
            const fractionMap = {
                'Â¼': '1/4',
                'Â½': '1/2',
                'Â¾': '3/4',
                'â…›': '1/8',
                'â…œ': '3/8',
                'â…': '5/8',
                'â…ž': '7/8',
                'â…“': '1/3',
                'â…”': '2/3'
            };
            let normalized = text
                .replace(/\u00A0/g, ' ')
                .replace(/\u2044/g, '/');
            normalized = normalized.replace(/(\d)([Â¼Â½Â¾â…›â…œâ…â…žâ…“â…”])/g, '$1 $2');
            normalized = normalized.replace(/[Â¼Â½Â¾â…›â…œâ…â…žâ…“â…”]/g, match => fractionMap[match] || match);
            normalized = normalized.replace(/\s+/g, ' ');
            normalized = normalized.replace(/(\d+)\s+(\d+\/\d+)/g, '$1-$2');
            // Normalize "11/2" => "1-1/2" when numerator is single digit
            return normalized.replace(/(\d)(\d)\/(\d)(?=\D|$)/g, '$1-$2/$3');
        }

        function isNumericLikeToken(token) {
            if (!token) {
                return false;
            }
            return /^\d+(\.\d+)?$/.test(token) || /^\d+\/\d+$/.test(token) || /^\d+-\d+\/\d+$/.test(token);
        }

        function formatItemDescriptionByPipeType(item) {
            const raw = (item.originalDescription || '').trim();
            if (!raw) {
                return raw;
            }
            const pipeType = (item.identifiedPipeType || '').toLowerCase();
            const normalized = normalizeFractionText(raw.replace(/["]/g, '').trim());
            const numberToken = '\\d+(?:\\.\\d+)?|\\d+-\\d+\\/\\d+|\\d+\\/\\d+';
            const xMatch = normalized.match(new RegExp(`(${numberToken})\\s*[xX]\\s*([A-Za-z0-9\\.\\/-]+)`));
            const hMatch = normalized.match(new RegExp(`^(${numberToken})\\s*(h|hv|hvy|heavy|hevy)$`, 'i'));
            const mMatch = normalized.match(new RegExp(`^(${numberToken})\\s*(m|med|medium)$`, 'i'));
            const schMatch = normalized.match(new RegExp(`^(${numberToken})\\s*(?:sch|schedule)\\s*(\\d+(?:\\.\\d+)?)$`, 'i'));
            let first = '';
            let secondDisplay = '';
            let secondClean = '';
            let isHeavy = false;
            let isMedium = false;
            let isSch = false;
            if (xMatch) {
                first = xMatch[1];
                secondDisplay = normalizeFractionText((xMatch[2] || '').trim());
                secondClean = secondDisplay.toLowerCase().replace(/[^a-z0-9]/g, '');
            } else if (hMatch) {
                first = hMatch[1];
                secondDisplay = hMatch[2];
                secondClean = hMatch[2].toLowerCase();
                isHeavy = true;
            } else if (mMatch) {
                first = mMatch[1];
                secondDisplay = mMatch[2];
                secondClean = mMatch[2].toLowerCase();
                isMedium = true;
            } else if (schMatch) {
                first = schMatch[1];
                secondDisplay = schMatch[2];
                secondClean = schMatch[2].toLowerCase();
                isSch = true;
            } else {
                return normalized;
            }

            if (pipeType.includes('seamless')) {
                if (isSch || isNumericLikeToken(secondClean)) {
                    return `${first}" NB X Sch ${secondDisplay || secondClean}`;
                }
                return normalized;
            }

            const isGi = pipeType.includes('gi') || pipeType.includes('galvanized');
            const isErw = pipeType.includes('erw');
            if (!isGi && !isErw) {
                return raw;
            }
            const pipeLabel = isGi ? 'GI' : 'ERW';
            const heavyTokens = ['h', 'hv', 'hvy', 'heavy', 'hevy'];
            const mediumTokens = ['m', 'med', 'medium'];

            if (isHeavy || heavyTokens.includes(secondClean)) {
                return `${first}" NB X Heavy -- ${pipeLabel}`;
            }
            if (isMedium || mediumTokens.includes(secondClean)) {
                return `${first}" NB X Medium -- ${pipeLabel}`;
            }
            if (isNumericLikeToken(secondClean)) {
                return `${first}" NB X ${secondDisplay || secondClean}mm thk -- ${pipeLabel}`;
            }
            return normalized;
        }

        function appendGroupedItems(tableBody, groupedItems, grandTotal) {
            // Step 6: Loop through each pipe type group
            Object.keys(groupedItems).forEach(function(pipeType) {
                const items = groupedItems[pipeType];
                let typeSubtotal = 0;
                
                // Step 6a: Create header row for this pipe type
                const headerRow = document.createElement('tr');
                headerRow.className = 'pipe-type-header';
                headerRow.id = `pipe-header-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
                headerRow.setAttribute('data-pipe-type', pipeType);
                const headerLabel = getPipeHeaderLabel(pipeType);
                headerRow.innerHTML = `
                    <td colspan="9">
                        <div style="display: flex; align-items: center; justify-content: space-between; gap: 10px;">
                            <input type="text" class="editable-field" data-field="pipeTypeHeader" value="${headerLabel}" style="flex: 1; border: none; background: transparent; font-weight: bold;">
                            <div style="display: flex; gap: 6px;">
                                <button onclick="addRow('${pipeType}', null, event)" title="Add item row" style="background: #4CAF50; color: white; border: none; padding: 4px 8px; cursor: pointer; border-radius: 3px; font-size: 12px;">âž•</button>
                                <button onclick="addRow('__NEW_HEADER__', '${headerRow.id}', event)" title="Add pipe type" style="background: #2196F3; color: white; border: none; padding: 4px 8px; cursor: pointer; border-radius: 3px; font-size: 12px;">H+</button>
                                <button onclick="deleteRow(event)" title="Delete pipe type" style="background: #f44336; color: white; border: none; padding: 4px 8px; cursor: pointer; border-radius: 3px; font-size: 12px;">ðŸ—‘ï¸</button>
                            </div>
                        </div>
                    </td>
                `;
                tableBody.appendChild(headerRow);
                
                // Step 6b: Create rows for each item in this pipe type
                items.forEach(function(item, index) {
                    const row = document.createElement('tr');
                    row.className = 'item-row';
                    const formattedDescription = formatItemDescriptionByPipeType(item);
                    const safeDescription = formattedDescription.replace(/"/g, '&quot;');
                    
                    // Calculate line total (quantity Ã— final rate)
                    const lineTotal = roundAmountToWhole(parseFloat(item.quantity) * parseFloat(item.finalRate));
                    grandTotal += lineTotal;
                    
                    // Generate unique row ID
                    const rowId = `row-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
                    row.id = rowId;
                    row.setAttribute('data-pipe-type', pipeType);
                    
                    // Create editable inputs for all fields (no pipe type column)
                    row.innerHTML = `
                        <td style="text-align: center; vertical-align: middle; padding: 5px;">
                            <div style="display: flex; flex-direction: column; align-items: center; gap: 5px;">
                                <button onclick="addRow('${pipeType}', null, event)" title="Add row" style="background: #4CAF50; color: white; border: none; padding: 4px 8px; cursor: pointer; border-radius: 3px; font-size: 14px; width: 28px; height: 28px; display: flex; align-items: center; justify-content: center;">âž•</button>
                                <button onclick="deleteRow(event)" title="Delete row" style="background: #f44336; color: white; border: none; padding: 4px 8px; cursor: pointer; border-radius: 3px; font-size: 14px; width: 28px; height: 28px; display: flex; align-items: center; justify-content: center;">âž–</button>
                            </div>
                        </td>
                        <td class="row-number">${index + 1}</td>
                        <td>
                            <input type="text" 
                                   class="editable-field" 
                                   data-field="originalDescription"
                                   data-pipe-type="${pipeType}"
                                   data-row-id="${rowId}"
                                   value="${safeDescription}">
                        </td>
                        <td>
                            <input type="number" 
                                   class="editable-field" 
                                   data-field="quantity"
                                   data-pipe-type="${pipeType}"
                                   data-row-id="${rowId}"
                                   value="${item.quantity}" 
                                   min="0" 
                                   step="1">
                        </td>
                        <td class="col-base-rate">
                            â‚¹<input type="number" 
                                   class="editable-field" 
                                   data-field="unitRate"
                                   data-pipe-type="${pipeType}"
                                   data-row-id="${rowId}"
                                   value="${item.unitRate}" 
                                   min="0" 
                                   step="0.01" style="width: 80px;">
                        </td>
                        <td class="col-margin">
                            <input type="number" 
                                   class="editable-field" 
                                   data-field="marginPercent"
                                   data-pipe-type="${pipeType}"
                                   data-row-id="${rowId}"
                                   value="${item.marginPercent || ''}" 
                                   min="0" 
                                   step="0.01" style="width: 60px;">
                        </td>
                        <td>â‚¹<input type="number" 
                                   class="editable-field rate-per-mtr" 
                                   data-field="finalRate"
                                   data-pipe-type="${pipeType}"
                                   data-row-id="${rowId}"
                                   value="${parseFloat(item.finalRate || 0).toFixed(2)}" 
                                   min="0" 
                                   step="0.01" style="width: 100px;"></td>
                        <td>â‚¹<input type="number" 
                                   class="editable-field line-total-input" 
                                   data-field="lineTotal"
                                   data-row-id="${rowId}"
                                   value="${lineTotal}"
                                   min="0" 
                                   step="1" style="width: 100px;"></td>
                    `;
                    
                    tableBody.appendChild(row);
                    
                    // Attach event listeners for recalculation
                    attachRowEventListeners(row);
                });
            });

            return grandTotal;
        }

        function renderGrandTotal(grandTotal) {
            // Step 7: Display grand total (amounts are whole numbers)
            document.getElementById('grandTotal').textContent = formatIndianNumber(roundAmountToWhole(grandTotal), true);
        }

        function hideNoCreationQuotationMessage() {
            // Step 8: Hide the "no quotation" message
            const noCreationMsg = document.getElementById('noCreationQuotation');
            if (noCreationMsg) {
                noCreationMsg.style.display = 'none';
            }
        }

        function showCreationQuotationContent() {
            // Step 9: Show the quotation content (header, table, totals, approve button, terms)
            document.getElementById('creationQuotationHeader').style.display = 'block';
            document.getElementById('quotationTable').style.display = 'table';
            document.getElementById('creationGrandTotal').style.display = 'block';
            document.getElementById('creationApproveBtn').style.display = 'block';
            document.getElementById('termsDivider').style.display = 'block';
            document.getElementById('termsBox').style.display = 'block';
            const termsText = document.getElementById('termsText');
            if (termsText && termsText.value.trim() === '' && defaultTermsText) {
                termsText.value = defaultTermsText;
            }
            const quoteNumberInput = document.getElementById('quoteNumber');
            if (quoteNumberInput && !quoteNumberInput.value.trim()) {
                consumeNextQuoteNumber()
                    .then(nextNumber => {
                        quoteNumberInput.value = nextNumber;
                    })
                    .catch(error => {
                        console.error('Failed to generate quote number:', error);
                    });
            }
        }

        function attachCreationCalculationListeners() {
            // Step 10: Add event listeners to all editable fields for real-time calculation
            attachCalculationListeners();
        }

        function scrollToQuotationSection() {
            // Step 11: Scroll to the quotation so user can see it
            document.getElementById('quotationSection').scrollIntoView({ 
                behavior: 'smooth' 
            });
        }

        function displayQuotation(data) {
            /*
                Parameter:
                - data: The quotation data object from mockAIExtraction
            */
            
            // Step 1: Fill in the header information (make editable)
            populateQuotationHeader(data);
            
            // Step 2: Get the table body element (where rows will be added)
            const tableBody = getQuotationTableBody();
            
            // Step 3: Clear any existing rows
            clearQuotationTableBody(tableBody);
            
            // Step 4: Group line items by pipe type
            const groupedItems = groupLineItemsByPipeType(data.lineItems);
            
            // Step 5: Calculate grand total
            let grandTotal = initializeGrandTotal();
            
            // Step 6: Loop through each pipe type group
            grandTotal = appendGroupedItems(tableBody, groupedItems, grandTotal);
            
            // Step 7: Display grand total
            renderGrandTotal(grandTotal);
            
            // Step 8: Hide the "no quotation" message
            hideNoCreationQuotationMessage();
            
            // Step 9: Show the quotation content (header, table, totals, approve button, terms)
            showCreationQuotationContent();
            
            // Step 10: Add event listeners to all editable fields for real-time calculation
            attachCreationCalculationListeners();
            
            // Step 11: Scroll to the quotation so user can see it
            scrollToQuotationSection();
        }
        
        /*
            ============================================
            ATTACH CALCULATION LISTENERS
            ============================================
            This function adds event listeners to all editable fields
            so that when users change values, totals are recalculated automatically.
        */
        function attachCalculationListeners() {
            /*
                This function finds all editable fields and makes them recalculate
                totals when their values change.
            */
            
            // Get all editable input fields
            const editableFields = document.querySelectorAll('.editable-field');
            
            // Add event listener to each field
            editableFields.forEach(function(field) {
                field.addEventListener('input', function() {
                    if (this.getAttribute('data-field') === 'lineTotal') {
                        this.dataset.manual = 'true';
                    }
                    // When any field changes, recalculate that row
                    recalculateRow(this);
                });
                
                field.addEventListener('change', function() {
                    // Also recalculate on change (when user leaves the field)
                    recalculateRow(this);
                });
            });
        }
        
        /*
            ============================================
            RECALCULATE ROW FUNCTION
            ============================================
            This function recalculates the final rate, line total, subtotals, and grand total
            when any field in a row is edited.
        */
        function recalculateRow(changedField) {
            /*
                Parameter:
                - changedField: The input field that was changed
            */
            
            // Get the row containing this field
            const row = changedField.closest('tr');
            if (!row || !row.classList.contains('item-row')) {
                return; // Not an item row, skip
            }
            
            // Get all fields in this row
            const quantity = parseFloat(row.querySelector('[data-field="quantity"]')?.value || 0) || 0;
            const unitRate = parseFloat(row.querySelector('[data-field="unitRate"]')?.value || 0) || 0;
            const marginValue = row.querySelector('[data-field="marginPercent"]')?.value || '';
            const marginPercent = marginValue === '' ? 0 : (parseFloat(marginValue) || 0);
            
            // Check if finalRate was edited directly
            const finalRateInput = row.querySelector('[data-field="finalRate"]');
            const lineTotalInput = row.querySelector('[data-field="lineTotal"]');
            const fieldChanged = changedField.getAttribute('data-field');
            
            let finalRate;
            if (fieldChanged === 'lineTotal' && lineTotalInput && lineTotalInput.dataset.manual === 'true') {
                const manualLineTotal = parseFloat(lineTotalInput.value || 0) || 0;
                if (quantity > 0) {
                    finalRate = manualLineTotal / quantity;
                    if (finalRateInput) {
                        finalRateInput.value = finalRate.toFixed(2);
                    }
                } else {
                    finalRate = 0;
                }
                lineTotalInput.dataset.manual = '';
            } else if (fieldChanged === 'finalRate') {
                // User edited finalRate directly - use that value
                finalRate = parseFloat(changedField.value || 0) || 0;
            } else {
                // Calculate final rate from unitRate and margin
                finalRate = unitRate * (1 + marginPercent / 100);
                // Update the finalRate input if it exists
                if (finalRateInput) {
                    finalRateInput.value = finalRate.toFixed(2);
                }
            }
            
            // Calculate line total: quantity Ã— final rate
            let lineTotal = quantity * finalRate;
            if (fieldChanged === 'lineTotal' && lineTotalInput) {
                const manualLineTotal = parseFloat(lineTotalInput.value || 0) || 0;
                lineTotal = quantity > 0 ? (quantity * finalRate) : manualLineTotal;
            }
            
            // Update the line total display (no decimals)
            if (lineTotalInput) {
                lineTotalInput.value = String(roundAmountToWhole(lineTotal));
            }
            
            // Recalculate all subtotals and grand total
            recalculateAllTotals();
        }
        
        /*
            ============================================
            RECALCULATE ALL TOTALS FUNCTION
            ============================================
            This function recalculates the grand total
            by going through all item rows and summing them up.
        */
        function recalculateAllTotals() {
            /*
                This function:
                1. Finds all item rows
                2. Calculates and updates grand total
            */
            
            // Get all item rows in Creation table
            const tableBody = document.getElementById('quotationTableBody');
            if (!tableBody) {
                return;
            }
            const itemRows = tableBody.querySelectorAll('.item-row');
            
            let grandTotal = 0;
            
            // Calculate grand total from all rows
            itemRows.forEach(function(row) {
                // Get line total for this row
                const lineTotalInput = row.querySelector('[data-field="lineTotal"]');
                let lineTotal = 0;
                if (lineTotalInput && lineTotalInput.tagName === 'INPUT') {
                    lineTotal = parseFloat(lineTotalInput.value || 0) || 0;
                } else {
                    const lineTotalSpan = row.querySelector('.line-total');
                    const lineTotalText = lineTotalSpan ? lineTotalSpan.textContent.replace('â‚¹', '').replace(/,/g, '') : '0';
                    lineTotal = parseFloat(lineTotalText) || 0;
                }
                grandTotal += roundAmountToWhole(lineTotal);
            });
            document.getElementById('grandTotal').textContent = formatIndianNumber(roundAmountToWhole(grandTotal), true);
        }
        
        /*
            ============================================
            ATTACH ROW EVENT LISTENERS FUNCTION
            ============================================
            Attaches event listeners to a row for recalculation
        */
        function attachRowEventListeners(row) {
            const editableFields = row.querySelectorAll('.editable-field');
            editableFields.forEach(function(field) {
                field.addEventListener('input', function() {
                    if (this.getAttribute('data-field') === 'lineTotal') {
                        this.dataset.manual = 'true';
                    }
                    recalculateRow(this);
                });
                field.addEventListener('blur', function() {
                    recalculateRow(this);
                });
            });
        }

        function attachCreationFolderCalculationListeners(entryId) {
            const folderContent = document.getElementById(`folder-content-${entryId}`);
            if (!folderContent) {
                return;
            }
            const editableFields = folderContent.querySelectorAll('.editable-field');
            editableFields.forEach(function(field) {
                field.addEventListener('input', function() {
                    if (this.getAttribute('data-field') === 'lineTotal') {
                        this.dataset.manual = 'true';
                    }
                    recalculateRowInContainer(this, folderContent);
                });
                field.addEventListener('blur', function() {
                    recalculateRowInContainer(this, folderContent);
                });
            });
        }

        function addCreationFolderRow(entryId, pipeType, insertAfterRow) {
            const folderContent = document.getElementById(`folder-content-${entryId}`);
            if (!folderContent) return;
            const table = folderContent.querySelector('table');
            const tableBody = table ? table.querySelector('tbody') : null;
            if (!tableBody) return;

            if (pipeType === '__NEW_HEADER__') {
                const existingHeaderCell = tableBody.querySelector('.pipe-type-header td[colspan]');
                const colspan = existingHeaderCell ? existingHeaderCell.getAttribute('colspan') : '8';
                const headerRow = document.createElement('tr');
                headerRow.className = 'pipe-type-header';
                headerRow.innerHTML = `
                    <td colspan="${colspan}">
                        <div style="display: flex; align-items: center; justify-content: space-between; gap: 10px;">
                            <input type="text" class="editable-field" data-field="pipeTypeHeader" value="Default" style="flex: 1; border: none; background: transparent; font-weight: bold;">
                            <div style="display: flex; gap: 6px;">
                                <button type="button" data-creation-entry-id="${entryId}" data-creation-action="add-row" data-creation-pipe-type="Default" title="Add item row" style="background: #4CAF50; color: white; border: none; padding: 4px 8px; cursor: pointer; border-radius: 3px; font-size: 12px;">âž•</button>
                                <button type="button" data-creation-entry-id="${entryId}" data-creation-action="add-header" title="Add pipe type" style="background: #2196F3; color: white; border: none; padding: 4px 8px; cursor: pointer; border-radius: 3px; font-size: 12px;">H+</button>
                                <button type="button" data-creation-entry-id="${entryId}" data-creation-action="delete-row" title="Delete pipe type" style="background: #f44336; color: white; border: none; padding: 4px 8px; cursor: pointer; border-radius: 3px; font-size: 12px;">ðŸ—‘ï¸</button>
                            </div>
                        </div>
                    </td>
                `;
                tableBody.appendChild(headerRow);
                attachCreationFolderCalculationListeners(entryId);
                recalculateAllTotalsInContainer(folderContent);
                return;
            }

            if (!pipeType) {
                const existingRows = tableBody.querySelectorAll('.item-row');
                pipeType = existingRows.length ? (existingRows[existingRows.length - 1].getAttribute('data-pipe-type') || 'Default') : 'Default';
            }
            const resolvedPipeType = pipeType;
            const row = document.createElement('tr');
            row.className = 'item-row';
            row.setAttribute('data-pipe-type', resolvedPipeType);
            const rowNumber = tableBody.querySelectorAll('.item-row').length + 1;
            row.innerHTML = `
                <td style="text-align: center; vertical-align: middle; padding: 5px;">
                    <div style="display: flex; flex-direction: column; align-items: center; gap: 5px;">
                        <button type="button" data-creation-entry-id="${entryId}" data-creation-action="add-row" data-creation-pipe-type="${resolvedPipeType}" title="Add row" style="background: #4CAF50; color: white; border: none; padding: 4px 8px; cursor: pointer; border-radius: 3px; font-size: 14px; width: 28px; height: 28px; display: flex; align-items: center; justify-content: center;">âž•</button>
                        <button type="button" data-creation-entry-id="${entryId}" data-creation-action="delete-row" title="Delete row" style="background: #f44336; color: white; border: none; padding: 4px 8px; cursor: pointer; border-radius: 3px; font-size: 14px; width: 28px; height: 28px; display: flex; align-items: center; justify-content: center;">âž–</button>
                    </div>
                </td>
                <td class="row-number">${rowNumber}</td>
                <td><input type="text" class="editable-field" data-field="originalDescription" data-pipe-type="${resolvedPipeType}" value="" placeholder="Enter description"></td>
                <td><input type="number" class="editable-field" data-field="quantity" data-pipe-type="${resolvedPipeType}" value="0" min="0" step="1"></td>
                <td class="col-base-rate">â‚¹<input type="number" class="editable-field" data-field="unitRate" data-pipe-type="${resolvedPipeType}" value="0" min="0" step="0.01" style="width: 80px;"></td>
                <td class="col-margin"><input type="number" class="editable-field" data-field="marginPercent" data-pipe-type="${resolvedPipeType}" value="" min="0" step="0.01" style="width: 60px;"></td>
                <td>â‚¹<input type="number" class="editable-field rate-per-mtr" data-field="finalRate" data-pipe-type="${resolvedPipeType}" value="0.00" min="0" step="0.01" style="width: 100px;"></td>
                <td>â‚¹<input type="number" class="editable-field line-total-input" data-field="lineTotal" value="0" min="0" step="1" style="width: 100px;"></td>
            `;
            if (insertAfterRow && insertAfterRow.parentNode === tableBody) {
                tableBody.insertBefore(row, insertAfterRow.nextElementSibling);
            } else {
                tableBody.appendChild(row);
            }
            attachCreationFolderCalculationListeners(entryId);
            recalculateAllTotalsInContainer(folderContent);
            updateRowNumbers(tableBody);
        }

        function deleteCreationFolderRow(entryId, ev) {
            const row = ev && ev.target ? ev.target.closest('tr') : null;
            if (!row || (!row.classList.contains('item-row') && !row.classList.contains('pipe-type-header'))) return;
            const folderContent = document.getElementById(`folder-content-${entryId}`);
            if (!folderContent || !row.closest('.quotation-folder-content') || row.closest('.quotation-folder-content') !== folderContent) return;
            const tableBody = row.closest('tbody');
            if (!tableBody) return;
            if (!confirm('Are you sure you want to delete this row?')) return;
            if (row.classList.contains('pipe-type-header')) {
                let nextRow = row.nextElementSibling;
                while (nextRow && !nextRow.classList.contains('pipe-type-header')) {
                    const toRemove = nextRow;
                    nextRow = nextRow.nextElementSibling;
                    toRemove.remove();
                }
            }
            row.remove();
            updateRowNumbers(tableBody);
            recalculateAllTotalsInContainer(folderContent);
        }

        function attachCreationFolderRowButtons(entryId) {
            const folderContent = document.getElementById(`folder-content-${entryId}`);
            if (!folderContent || folderContent.getAttribute('data-creation-delegate') === '1') return;
            folderContent.setAttribute('data-creation-delegate', '1');
            folderContent.querySelectorAll('button[onclick*="addRow"], button[onclick*="deleteRow"]').forEach(function(btn) {
                const onclick = btn.getAttribute('onclick') || '';
                if (onclick.indexOf('__NEW_HEADER__') !== -1) {
                    btn.setAttribute('data-creation-entry-id', entryId);
                    btn.setAttribute('data-creation-action', 'add-header');
                } else if (onclick.indexOf('addRow') !== -1) {
                    const tr = btn.closest('tr');
                    const pipeType = (tr && tr.getAttribute('data-pipe-type')) || (tr && tr.querySelector('input[data-field="pipeTypeHeader"]') && tr.querySelector('input[data-field="pipeTypeHeader"]').value) || 'Default';
                    btn.setAttribute('data-creation-entry-id', entryId);
                    btn.setAttribute('data-creation-action', 'add-row');
                    btn.setAttribute('data-creation-pipe-type', pipeType);
                } else if (onclick.indexOf('deleteRow') !== -1) {
                    btn.setAttribute('data-creation-entry-id', entryId);
                    btn.setAttribute('data-creation-action', 'delete-row');
                }
                btn.removeAttribute('onclick');
            });
            folderContent.addEventListener('click', function(ev) {
                const btn = ev.target.closest('button[data-creation-entry-id]');
                if (!btn || btn.getAttribute('data-creation-entry-id') !== entryId) return;
                const action = btn.getAttribute('data-creation-action');
                const eid = btn.getAttribute('data-creation-entry-id');
                if (action === 'add-row') {
                    addCreationFolderRow(eid, btn.getAttribute('data-creation-pipe-type') || 'Default', btn.closest('tr'));
                } else if (action === 'add-header') {
                    addCreationFolderRow(eid, '__NEW_HEADER__', null);
                } else if (action === 'delete-row') {
                    deleteCreationFolderRow(eid, ev);
                }
            });
        }

        function recalculateRowInContainer(changedField, container) {
            const row = changedField.closest('tr');
            if (!row || !row.classList.contains('item-row')) {
                return;
            }
            const quantity = parseFloat(row.querySelector('[data-field="quantity"]')?.value || 0) || 0;
            const unitRate = parseFloat(row.querySelector('[data-field="unitRate"]')?.value || 0) || 0;
            const marginValue = row.querySelector('[data-field="marginPercent"]')?.value || '';
            const marginPercent = marginValue === '' ? 0 : (parseFloat(marginValue) || 0);
            const finalRateInput = row.querySelector('[data-field="finalRate"]');
            const lineTotalInput = row.querySelector('[data-field="lineTotal"]');
            const fieldChanged = changedField.getAttribute('data-field');

            let finalRate;
            if (fieldChanged === 'lineTotal' && lineTotalInput && lineTotalInput.dataset.manual === 'true') {
                const manualLineTotal = parseFloat(lineTotalInput.value || 0) || 0;
                if (quantity > 0) {
                    finalRate = manualLineTotal / quantity;
                    if (finalRateInput) {
                        finalRateInput.value = finalRate.toFixed(2);
                    }
                } else {
                    finalRate = 0;
                }
                lineTotalInput.dataset.manual = '';
            } else if (fieldChanged === 'finalRate') {
                finalRate = parseFloat(changedField.value || 0) || 0;
            } else {
                finalRate = unitRate * (1 + marginPercent / 100);
                if (finalRateInput) {
                    finalRateInput.value = finalRate.toFixed(2);
                }
            }

            let lineTotal = quantity * finalRate;
            if (fieldChanged === 'lineTotal' && lineTotalInput) {
                const manualLineTotal = parseFloat(lineTotalInput.value || 0) || 0;
                lineTotal = quantity > 0 ? (quantity * finalRate) : manualLineTotal;
            }
            if (lineTotalInput) {
                lineTotalInput.value = String(roundAmountToWhole(lineTotal));
            }

            recalculateAllTotalsInContainer(container);
        }

        function recalculateAllTotalsInContainer(container) {
            if (!container) {
                return;
            }
            const tableBody = container.querySelector('tbody');
            if (!tableBody) {
                return;
            }
            const itemRows = tableBody.querySelectorAll('.item-row');
            let grandTotal = 0;
            itemRows.forEach(function(row) {
                const lineTotalInput = row.querySelector('[data-field="lineTotal"]');
                let lineTotal = 0;
                if (lineTotalInput && lineTotalInput.tagName === 'INPUT') {
                    lineTotal = parseFloat(lineTotalInput.value || 0) || 0;
                } else {
                    const lineTotalSpan = row.querySelector('.line-total');
                    const lineTotalText = lineTotalSpan ? lineTotalSpan.textContent.replace('â‚¹', '').replace(/,/g, '') : '0';
                    lineTotal = parseFloat(lineTotalText) || 0;
                }
                grandTotal += roundAmountToWhole(lineTotal);
            });
            const totalEl = container.querySelector('.grand-total span');
            if (totalEl) {
                totalEl.textContent = `Total: â‚¹${formatIndianNumber(roundAmountToWhole(grandTotal), true)}`;
            }
        }
        
        /*
            ============================================
            DELETE ROW FUNCTION
            ============================================
            Deletes a row from the table and recalculates totals
        */
        function deleteRow(rowIdOrEvent) {
            let row = null;
            if (rowIdOrEvent && typeof rowIdOrEvent === 'object' && rowIdOrEvent.target) {
                row = rowIdOrEvent.target.closest('tr');
            } else if (typeof rowIdOrEvent === 'string') {
                row = document.getElementById(rowIdOrEvent);
            }
            if (!row || (!row.classList.contains('item-row') && !row.classList.contains('pipe-type-header'))) {
                return;
            }
            const tableBody = row.closest('tbody');
            const container = tableBody ? tableBody.closest('.quotation-folder-content') : null;

            if (confirm('Are you sure you want to delete this row?')) {
                if (row.classList.contains('pipe-type-header')) {
                    let nextRow = row.nextElementSibling;
                    while (nextRow && !nextRow.classList.contains('pipe-type-header')) {
                        const rowToRemove = nextRow;
                        nextRow = nextRow.nextElementSibling;
                        rowToRemove.remove();
                    }
                }
                row.remove();
                if (container && tableBody) {
                    updateRowNumbers(tableBody);
                    recalculateAllTotalsInContainer(container);
                } else {
                    updateRowNumbers(tableBody || undefined);
                    recalculateAllTotals();
                }
            }
        }
        
        /*
            ============================================
            UPDATE ROW NUMBERS FUNCTION
            ============================================
            Updates the serial numbers in the table after row deletion
        */
        function updateRowNumbers(tableBody) {
            const itemRows = tableBody ? tableBody.querySelectorAll('.item-row') : document.querySelectorAll('.item-row');
            itemRows.forEach(function(row, index) {
                const rowNumberCell = row.querySelector('.row-number');
                if (rowNumberCell) {
                    rowNumberCell.textContent = index + 1;
                }
            });
        }
        
        /*
            ============================================
            ADD ROW FUNCTION
            ============================================
            Adds a new empty row to the table
        */
        function addRow(pipeType, insertAfterId, ev) {
            const tableBody = (ev && ev.target) ? (ev.target.closest('table') && ev.target.closest('table').querySelector('tbody')) : null;
            const tableBodyFallback = document.getElementById('quotationTableBody');
            const tableBodyToUse = tableBody || tableBodyFallback;
            if (!tableBodyToUse) {
                return;
            }
            const container = tableBodyToUse.closest('.quotation-folder-content');
            
            if (pipeType === '__NEW_HEADER__') {
                const existingHeaderCell = tableBodyToUse.querySelector('.pipe-type-header td[colspan]');
                const colspan = existingHeaderCell ? existingHeaderCell.getAttribute('colspan') : '8';
                const headerRow = document.createElement('tr');
                headerRow.className = 'pipe-type-header';
                headerRow.id = `pipe-header-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
                headerRow.setAttribute('data-pipe-type', 'Default');
                headerRow.innerHTML = `
                    <td colspan="${colspan}">
                        <div style="display: flex; align-items: center; justify-content: space-between; gap: 10px;">
                            <input type="text" class="editable-field" data-field="pipeTypeHeader" value="Default" style="flex: 1; border: none; background: transparent; font-weight: bold;">
                            <div style="display: flex; gap: 6px;">
                                <button onclick="addRow('Default', null, event)" title="Add item row" style="background: #4CAF50; color: white; border: none; padding: 4px 8px; cursor: pointer; border-radius: 3px; font-size: 12px;">âž•</button>
                                <button onclick="addRow('__NEW_HEADER__', '${headerRow.id}', event)" title="Add pipe type" style="background: #2196F3; color: white; border: none; padding: 4px 8px; cursor: pointer; border-radius: 3px; font-size: 12px;">H+</button>
                                <button onclick="deleteRow(event)" title="Delete pipe type" style="background: #f44336; color: white; border: none; padding: 4px 8px; cursor: pointer; border-radius: 3px; font-size: 12px;">ðŸ—‘ï¸</button>
                            </div>
                        </div>
                    </td>
                `;
                tableBodyToUse.appendChild(headerRow);
                if (container) {
                    const entryId = container.id && container.id.startsWith('folder-content-') ? container.id.replace('folder-content-', '') : '';
                    if (entryId) attachCreationFolderCalculationListeners(entryId);
                    recalculateAllTotalsInContainer(container);
                }
                return;
            }
            
            // If no pipe type specified, use the last pipe type or create a default one
            if (!pipeType) {
                const existingRows = tableBodyToUse.querySelectorAll('.item-row');
                if (existingRows.length > 0) {
                    const lastRow = existingRows[existingRows.length - 1];
                    pipeType = lastRow.getAttribute('data-pipe-type') || 'Default';
                } else {
                    pipeType = 'Default';
                    // Create a header row if it doesn't exist
                    const existingHeaderCell = tableBodyToUse.querySelector('.pipe-type-header td[colspan]');
                    const colspan = existingHeaderCell ? existingHeaderCell.getAttribute('colspan') : '8';
                    const headerRow = document.createElement('tr');
                    headerRow.className = 'pipe-type-header';
                    headerRow.id = `pipe-header-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
                    headerRow.setAttribute('data-pipe-type', pipeType);
                    headerRow.innerHTML = `
                        <td colspan="${colspan}">
                            <div style="display: flex; align-items: center; justify-content: space-between; gap: 10px;">
                                <input type="text" class="editable-field" data-field="pipeTypeHeader" value="${pipeType}" style="flex: 1; border: none; background: transparent; font-weight: bold;">
                                <div style="display: flex; gap: 6px;">
                                    <button onclick="addRow('${pipeType}', null, event)" title="Add item row" style="background: #4CAF50; color: white; border: none; padding: 4px 8px; cursor: pointer; border-radius: 3px; font-size: 12px;">âž•</button>
                                    <button onclick="addRow('__NEW_HEADER__', '${headerRow.id}', event)" title="Add pipe type" style="background: #2196F3; color: white; border: none; padding: 4px 8px; cursor: pointer; border-radius: 3px; font-size: 12px;">H+</button>
                                    <button onclick="deleteRow(event)" title="Delete pipe type" style="background: #f44336; color: white; border: none; padding: 4px 8px; cursor: pointer; border-radius: 3px; font-size: 12px;">ðŸ—‘ï¸</button>
                                </div>
                            </div>
                        </td>
                    `;
                    tableBodyToUse.appendChild(headerRow);
                }
            }
            
            const resolvedPipeType = pipeType;
            
            // Create new row
            const row = document.createElement('tr');
            row.className = 'item-row';
            const rowId = `row-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
            row.id = rowId;
            row.setAttribute('data-pipe-type', resolvedPipeType);
            
            const rowNumber = tableBodyToUse.querySelectorAll('.item-row').length + 1;
            
            row.innerHTML = `
                <td style="text-align: center; vertical-align: middle; padding: 5px;">
                    <div style="display: flex; flex-direction: column; align-items: center; gap: 5px;">
                        <button onclick="addRow('${pipeType}', null, event)" title="Add row" style="background: #4CAF50; color: white; border: none; padding: 4px 8px; cursor: pointer; border-radius: 3px; font-size: 14px; width: 28px; height: 28px; display: flex; align-items: center; justify-content: center;">âž•</button>
                        <button onclick="deleteRow(event)" title="Delete row" style="background: #f44336; color: white; border: none; padding: 4px 8px; cursor: pointer; border-radius: 3px; font-size: 14px; width: 28px; height: 28px; display: flex; align-items: center; justify-content: center;">âž–</button>
                    </div>
                </td>
                <td class="row-number">${rowNumber}</td>
                <td>
                    <input type="text" 
                           class="editable-field" 
                           data-field="originalDescription"
                           data-pipe-type="${resolvedPipeType}"
                           data-row-id="${rowId}"
                           value="" placeholder="Enter description">
                </td>
                <td>
                    <input type="number" 
                           class="editable-field" 
                           data-field="quantity"
                           data-pipe-type="${resolvedPipeType}"
                           data-row-id="${rowId}"
                           value="0" 
                           min="0" 
                           step="1">
                </td>
                <td class="col-base-rate">
                    â‚¹<input type="number" 
                           class="editable-field" 
                           data-field="unitRate"
                           data-pipe-type="${resolvedPipeType}"
                           data-row-id="${rowId}"
                           value="0" 
                           min="0" 
                           step="0.01" style="width: 80px;">
                </td>
                <td class="col-margin">
                    <input type="number" 
                           class="editable-field" 
                           data-field="marginPercent"
                           data-pipe-type="${resolvedPipeType}"
                           data-row-id="${rowId}"
                           value="" 
                           min="0" 
                           step="0.01" style="width: 60px;">
                </td>
                <td>â‚¹<input type="number" 
                           class="editable-field rate-per-mtr" 
                           data-field="finalRate"
                           data-pipe-type="${resolvedPipeType}"
                           data-row-id="${rowId}"
                           value="0.00" 
                           min="0" 
                           step="0.01" style="width: 100px;"></td>
                <td>â‚¹<input type="number" 
                           class="editable-field line-total-input" 
                           data-field="lineTotal"
                           data-row-id="${rowId}"
                           value="0"
                           min="0" 
                           step="1" style="width: 100px;"></td>
            `;
            
            tableBodyToUse.appendChild(row);
            if (container) {
                const entryId = container.id && container.id.startsWith('folder-content-') ? container.id.replace('folder-content-', '') : '';
                if (entryId) attachCreationFolderCalculationListeners(entryId);
                recalculateAllTotalsInContainer(container);
                updateRowNumbers(tableBodyToUse);
            } else {
                attachRowEventListeners(row);
                recalculateAllTotals();
            }
        }

        function setLogoSource() {
            const logoImg = document.getElementById('logoImg');
            const logoText = document.getElementById('logoText');
            
            if (!logoImg) {
                return;
            }

            // Set up handlers BEFORE changing the src
            logoImg.onload = function() {
                // Image loaded successfully - show image, hide text
                this.style.display = 'block';
                if (logoText) {
                    logoText.style.display = 'none';
                }
            };
            
            logoImg.onerror = function() {
                // Image failed to load - hide image, show text
                this.style.display = 'none';
                if (logoText) {
                    logoText.style.display = 'block';
                }
            };

            // Now set the src (this will trigger onload or onerror)
            const logoUrl = `${window.location.origin}/logo.png?v=${Date.now()}`;
            logoImg.src = logoUrl;
            logoImg.style.display = 'block'; // Make it visible so it can load
        }

        function toggleConfigSection() {
            const content = document.getElementById('configContent');
            const button = document.querySelector('.config-toggle-btn');
            if (!content || !button) {
                return;
            }

            const isHidden = content.style.display === 'none' || content.style.display === '';
            content.style.display = isHidden ? 'block' : 'none';
            button.textContent = isHidden ? 'Hide' : 'Show';
        }

        function normalizeTermsText(text) {
            if (!text) {
                return text;
            }

            const letters = text.replace(/[^A-Za-z]/g, '');
            if (!letters) {
                return text;
            }

            const upperCount = letters.replace(/[^A-Z]/g, '').length;
            const upperRatio = upperCount / letters.length;
            if (upperRatio < 0.6) {
                return text;
            }

            return text.split('\n').map(line => {
                const trimmed = line.trim();
                if (!trimmed) {
                    return '';
                }

                const match = trimmed.match(/^(\d+\.\s*)(.*)$/);
                const body = (match ? match[2] : trimmed).toLowerCase();
                const normalizedBody = body.charAt(0).toUpperCase() + body.slice(1);
                return match ? (match[1] + normalizedBody) : normalizedBody;
            }).join('\n');
        }
        
        /*
            ============================================
            NORMALIZE NUMBER VALUE FUNCTION
            ============================================
            Helper function to fix floating-point precision issues
            (e.g., 5 -> 4.99). Normalizes values that are very close
            to whole numbers to the actual whole number.
        */
        function normalizeNumberValue(value) {
            if (value === '' || value === null || value === undefined) {
                return value;
            }
            const numValue = parseFloat(value);
            if (isNaN(numValue)) {
                return value; // Return as-is if not a number
            }
            // If the value is very close to a whole number (within 0.01), round it to the whole number
            const rounded = Math.round(numValue);
            if (Math.abs(numValue - rounded) < 0.01) {
                return String(rounded);
            }
            // Otherwise, return the original value as a string
            return String(value);
        }
        
        /*
            ============================================
            APPROVE QUOTATION FUNCTION
            ============================================
            This function adds the quotation to the Approval section
            and stores it in the approvedQuotations array.
        */
        function getQuotationHeaderValues() {
            // Get all quotation data
            const quotationDate = document.getElementById('quotationDate').value;
            const customerName = document.getElementById('kindAttn').value || '';
            const projectName = document.getElementById('billTo').value || '';
            const shipTo = document.getElementById('shipTo').value || '';
            const phoneNumber = document.getElementById('phoneNumber') ? document.getElementById('phoneNumber').value : '';
            const mobileNumber = document.getElementById('mobileNumber') ? document.getElementById('mobileNumber').value : '';
            const preparedBy = document.getElementById('preparedBy') ? document.getElementById('preparedBy').value : '';
            const assignedTo = document.getElementById('assignedTo') ? document.getElementById('assignedTo').value : '';
            const checkedBy = document.getElementById('checkedBy') ? document.getElementById('checkedBy').value : '';
            const quoteNumber = document.getElementById('quoteNumber') ? document.getElementById('quoteNumber').value : '';
            const contactDetails = mobileNumber || phoneNumber || '';
            const grandTotal = document.getElementById('grandTotal').textContent;
            const termsTextRaw = document.getElementById('termsText') ? document.getElementById('termsText').value : '';
            const termsText = normalizeTermsText(termsTextRaw);
            if (document.getElementById('termsText') && termsText !== termsTextRaw) {
                document.getElementById('termsText').value = termsText;
            }

            return {
                quotationDate,
                customerName,
                projectName,
                contactDetails,
                phoneNumber,
                mobileNumber,
                shipTo,
                preparedBy,
                assignedTo,
                checkedBy,
                quoteNumber,
                grandTotal,
                termsText
            };
        }

        function cloneQuotationTableWithValues(quotationTable) {
            // Clone the table first
            const tableClone = quotationTable.cloneNode(true);

            // Update all cloned table input values to match current values from original
            const originalTableInputs = quotationTable.querySelectorAll('input, textarea');
            originalTableInputs.forEach((originalInput) => {
                let currentValue = originalInput.value;
                
                // Try to find matching input in clone by data attributes or position
                let clonedInput = null;
                
                // First try to match by data attributes if they exist
                if (originalInput.hasAttribute('data-field') && originalInput.hasAttribute('data-row-index')) {
                    clonedInput = tableClone.querySelector(
                        `input[data-field="${originalInput.getAttribute('data-field')}"][data-row-index="${originalInput.getAttribute('data-row-index')}"]`
                    );
                } else if (originalInput.id) {
                    clonedInput = tableClone.querySelector(`#${originalInput.id}`);
                }
                
                // If no match by attributes, try to match by type and position
                if (!clonedInput) {
                    const allClonedInputs = tableClone.querySelectorAll('input, textarea');
                    const originalIndex = Array.from(originalTableInputs).indexOf(originalInput);
                    if (allClonedInputs[originalIndex]) {
                        clonedInput = allClonedInputs[originalIndex];
                    }
                }
                
                if (clonedInput) {
                    // For number inputs, preserve the exact string value to avoid precision issues
                    if (originalInput.type === 'number') {
                        // Normalize the value to fix floating-point precision issues (e.g., 5 -> 4.99)
                        let exactValue = normalizeNumberValue(currentValue);
                        
                        // Set both value property and attribute
                        clonedInput.value = exactValue;
                        clonedInput.setAttribute('value', exactValue);
                    } else {
                        clonedInput.value = currentValue;
                        // Set the value attribute so it's preserved in outerHTML
                        clonedInput.setAttribute('value', currentValue);
                        // For textarea, also update the text content
                        if (originalInput.tagName === 'TEXTAREA') {
                            clonedInput.textContent = currentValue;
                        }
                    }
                }
            });

            return tableClone;
        }

        function cloneQuotationHeaderWithValues(quotationHeader) {
            // Clone the header first
            const headerClone = quotationHeader.cloneNode(true);
            headerClone.style.display = 'block'; // Make sure it's visible in the clone
            
            // Update all cloned header input values to match current values from original
            const originalHeaderInputs = quotationHeader.querySelectorAll('input, textarea');
            originalHeaderInputs.forEach((originalInput) => {
                const currentValue = originalInput.value;
                
                // Try to find matching input in clone by ID (most reliable for header inputs)
                let clonedInput = null;
                
                if (originalInput.id) {
                    clonedInput = headerClone.querySelector(`#${originalInput.id}`);
                }
                
                // If no match by ID, try to match by type and position
                if (!clonedInput) {
                    const allClonedInputs = headerClone.querySelectorAll('input, textarea');
                    const originalIndex = Array.from(originalHeaderInputs).indexOf(originalInput);
                    if (allClonedInputs[originalIndex]) {
                        clonedInput = allClonedInputs[originalIndex];
                    }
                }
                
                if (clonedInput) {
                    clonedInput.value = currentValue;
                    // Set the value attribute so it's preserved in outerHTML
                    clonedInput.setAttribute('value', currentValue);
                    // For textarea, also update the text content
                    if (originalInput.tagName === 'TEXTAREA') {
                        clonedInput.textContent = currentValue;
                    }
                    if (originalInput.id) {
                        clonedInput.setAttribute('data-field', originalInput.id);
                    }
                }
            });

            return headerClone;
        }

        function buildQuotationData(quotationHeaderValues, tableClone, headerClone) {
            const {
                quotationDate,
                customerName,
                projectName,
                contactDetails,
                shipTo,
                phoneNumber,
                mobileNumber,
                preparedBy,
                assignedTo,
                checkedBy,
                quoteNumber,
                grandTotal,
                termsText
            } = quotationHeaderValues;

            // Create quotation object to store
            const quotationData = {
                id: Date.now(), // Unique ID based on timestamp
                customerName: customerName,
                projectName: projectName,
                contactDetails: contactDetails,
                quotationDate: quotationDate,
                grandTotal: grandTotal,
                tableHTML: tableClone.outerHTML,
                headerHTML: headerClone.outerHTML, // Store full header HTML with current values
                termsText: termsText,
                shipTo: shipTo,
                preparedBy: preparedBy,
                assignedTo: assignedTo,
                phoneNumber: phoneNumber,
                mobileNumber: mobileNumber,
                checkedBy: checkedBy,
                quoteNumber: quoteNumber
            };

            return quotationData;
        }

        function addQuotationToApprovedQuotations(quotationData) {
            // Add to approved quotations array (not saved yet - needs approval)
            const quotationWithStatus = {
                ...quotationData,
                saved: false  // Not approved yet - will show full content with Approve button
            };
            approvedQuotations.push(quotationWithStatus);
            return quotationWithStatus;
        }

        function persistAndRefreshApprovals() {
            // Automatically persist all quotations (including unapproved ones)
            saveToLocalStorage();
            
            // Clear the Creation section (quotation disappears from Creation)
            clearCreationSection();
            
            // Display all approved quotations
            displayAllApprovedQuotations();
        }

        function scrollToApprovalSection() {
            // Scroll to Approval section
            document.getElementById('approvalSection').scrollIntoView({ 
                behavior: 'smooth' 
            });
        }

        async function approveQuotation() {
            /*
                This function:
                1. Gets all quotation data from the creation section
                2. Creates a copy and adds it to the approved quotations array
                3. Displays all approved quotations in the Approval section
                4. Hides the creation section quotation
            */
            
            const quoteNumberInput = document.getElementById('quoteNumber');
            if (quoteNumberInput && !quoteNumberInput.value.trim()) {
                try {
                    quoteNumberInput.value = await consumeNextQuoteNumber();
                } catch (error) {
                    console.error('Failed to generate quote number:', error);
                }
            }
            const quotationHeaderValues = getQuotationHeaderValues();
            
            // Get the table HTML - ensure all current input values are captured
            const quotationTable = document.getElementById('quotationTable');
            const tableClone = cloneQuotationTableWithValues(quotationTable);
            
            // Get the header - ensure all current input values are captured
            const quotationHeader = document.getElementById('creationQuotationHeader');
            const headerClone = cloneQuotationHeaderWithValues(quotationHeader);
            
            const quotationData = buildQuotationData(quotationHeaderValues, tableClone, headerClone);
            quotationData.emailContent = document.getElementById('emailContent')?.value || lastEmailContent || '';
            quotationData.emailContentHtml = lastEmailHtmlContent || '';
            quotationData.fileContent = lastFileContent || '';
            const quotationWithStatus = addQuotationToApprovedQuotations(quotationData);
            await saveQuotationToBackend(quotationWithStatus);
            persistAndRefreshApprovals();
            scrollToApprovalSection();
        }

        function getInputValueFromContainer(container, fieldId) {
            if (!container) {
                return '';
            }
            const input = container.querySelector(`[data-field="${fieldId}"]`) || container.querySelector(`#${fieldId}`);
            return input ? input.value : '';
        }

        function getQuotationHeaderValuesFromContainer(container) {
            const quotationDate = getInputValueFromContainer(container, 'quotationDate');
            const customerName = getInputValueFromContainer(container, 'kindAttn') || '';
            const projectName = getInputValueFromContainer(container, 'billTo') || '';
            const shipTo = getInputValueFromContainer(container, 'shipTo') || '';
            const phoneNumber = getInputValueFromContainer(container, 'phoneNumber') || '';
            const mobileNumber = getInputValueFromContainer(container, 'mobileNumber') || '';
            const preparedBy = getInputValueFromContainer(container, 'preparedBy') || '';
            const assignedTo = getInputValueFromContainer(container, 'assignedTo') || '';
            const checkedBy = getInputValueFromContainer(container, 'checkedBy') || '';
            const quoteNumber = getInputValueFromContainer(container, 'quoteNumber') || '';
            const contactDetails = mobileNumber || phoneNumber || '';
            const grandTotal = getGrandTotalFromContainer(container);
            const termsTextRaw = getTermsTextFromContainer(container);
            const termsText = normalizeTermsText(termsTextRaw);

            return {
                quotationDate,
                customerName,
                projectName,
                contactDetails,
                phoneNumber,
                mobileNumber,
                shipTo,
                preparedBy,
                assignedTo,
                checkedBy,
                quoteNumber,
                grandTotal,
                termsText
            };
        }

        function getGrandTotalFromContainer(container) {
            if (!container) {
                return '';
            }
            const totalEl = container.querySelector('.grand-total span');
            const totalText = totalEl ? totalEl.textContent : '';
            const match = totalText.match(/â‚¹\s*([0-9,]+(?:\.\d+)?)/);
            return match ? match[1] : '';
        }

        function getTermsTextFromContainer(container) {
            if (!container) {
                return '';
            }
            const termsTextarea = container.querySelector('.terms-box textarea');
            if (termsTextarea) {
                return termsTextarea.value || '';
            }
            const termsEl = container.querySelector('.terms-box div');
            return termsEl ? termsEl.textContent : '';
        }

        async function approveQuotationFromCreationFolder(entryId) {
            const folderContent = document.getElementById(`folder-content-${entryId}`);
            if (!folderContent) {
                return;
            }
            const folderState = creationFolderState[entryId] || {};
            const quotationHeaderValues = getQuotationHeaderValuesFromContainer(folderContent);
            const quotationTable = folderContent.querySelector('table');
            const tableClone = quotationTable ? cloneQuotationTableWithValues(quotationTable) : null;
            const quotationHeader = folderContent.querySelector('.quotation-header');
            const headerClone = quotationHeader ? cloneQuotationHeaderWithValues(quotationHeader) : null;
            let quoteNumber = (folderContent.querySelector('[data-field="quoteNumber"], #quoteNumber') || {}).value || '';
            removeCreationFolderEntry(entryId);
            if (!quoteNumber.trim()) {
                try {
                    quoteNumber = await consumeNextQuoteNumber();
                } catch (error) {
                    console.error('Failed to generate quote number:', error);
                }
            }
            quotationHeaderValues.quoteNumber = quoteNumber;
            const quotationData = buildQuotationData(quotationHeaderValues, tableClone, headerClone);
            quotationData.emailContent = folderState.emailContent || '';
            quotationData.emailContentHtml = folderState.emailContentHtml || '';
            quotationData.fileContent = folderState.fileContent || '';
            const quotationWithStatus = addQuotationToApprovedQuotations(quotationData);
            await saveQuotationToBackend(quotationWithStatus);
            persistAndRefreshApprovals();
            scrollToApprovalSection();
        }
        
        /*
            ============================================
            DISPLAY ALL APPROVED QUOTATIONS FUNCTION
            ============================================
            This function displays all approved quotations in the Approval section.
        */
        function getApprovedQuotationsContainer() {
            return document.getElementById('approvedQuotationsContainer');
        }

        function renderNoApprovedQuotationsMessage(container) {
            container.innerHTML = `
                <p id="noApprovedQuotations" style="text-align: center; color: #999; padding: 20px;">
                    No quotations approved yet. Create and approve a quotation to see it here.
                </p>
            `;
        }

        function hideNoApprovedQuotationsMessage() {
            // Hide the "no quotations" message
            const noQuotationsMsg = document.getElementById('noApprovedQuotations');
            if (noQuotationsMsg) {
                noQuotationsMsg.style.display = 'none';
            }
        }

        function buildAllApprovedQuotationsHTMLForList(quotationsList) {
            // Build HTML for all approved quotations
            let allQuotationsHTML = '';
            const sourceList = Array.isArray(quotationsList) ? quotationsList : [];
            
            // Show all quotations as collapsible folders (list is already newest-first from caller)
            sourceList.forEach(function(quotation, index) {
                const quotationNumber = sourceList.length - index;
                const contactNumber = extractContactNumber(quotation.contactDetails);
                let folderName = quotation.customerName;
                if (contactNumber) {
                    folderName += ` (${contactNumber})`;
                }
                const termsText = quotation.termsText || defaultTermsText || '';
                
                // Show APPROVED badge only if saved, with checked by name
                const checkedByName = quotation.checkedBy ? ` - ${quotation.checkedBy}` : '';
                const approvedBadgeHTML = quotation.saved 
                    ? `<span class="saved-badge">APPROVED${checkedByName}</span>` 
                    : '';
                const assignedToName = quotation.assignedTo ? ` - ${quotation.assignedTo}` : '';
                const assignedBadgeHTML = quotation.assignedTo
                    ? `<span class="saved-badge assigned-badge">ASSIGNED TO${assignedToName}</span>`
                    : '';
                
                // Show Approve button only if not saved yet
                const approveButtonHTML = `<button class="save-btn" onclick="saveQuotation(${quotation.id})">âœ… Approve</button>`;
                const saveButtonHTML = `<button class="save-btn" onclick="saveQuotationChanges(${quotation.id})">ðŸ’¾ Save</button>`;
                const downloadButtonHTML = `<button class="save-btn" onclick="downloadQuotationPdf(${quotation.id})">â¬‡ï¸ Download PDF</button>`;

                allQuotationsHTML += `
                    <div class="quotation-folder" id="folder-${quotation.id}">
                        <div class="quotation-folder-header" onclick="toggleQuotationFolder(${quotation.id})">
                            <span>
                                <span class="folder-icon">ðŸ“</span>
                                ${folderName}
                                ${approvedBadgeHTML}
                                ${assignedBadgeHTML}
                            </span>
                            <span class="folder-toggle-icon">â–¶</span>
                        </div>
                        <div class="quotation-folder-content" id="folder-content-${quotation.id}">
                            ${buildApprovalSplitLayout({
                                quotation,
                                termsText,
                                approveButtonHTML,
                                saveButtonHTML,
                                downloadButtonHTML
                            })}
                        </div>
                    </div>
                `;
            });

            return allQuotationsHTML;
        }

        function buildAllApprovedQuotationsHTML() {
            return buildAllApprovedQuotationsHTMLForList(approvedQuotations);
        }

        function normalizeSearchText(value) {
            return String(value || '').toLowerCase().trim();
        }

        function idsMatch(a, b) {
            return String(a) === String(b);
        }

        function getMonthIndexFromToken(token) {
            const months = [
                'january', 'february', 'march', 'april', 'may', 'june',
                'july', 'august', 'september', 'october', 'november', 'december'
            ];
            const cleanToken = normalizeSearchText(token);
            if (!cleanToken) {
                return -1;
            }
            const monthIndex = months.findIndex(month => month.startsWith(cleanToken));
            return monthIndex;
        }

        function getMonthIndexFromDateText(dateText) {
            const normalized = normalizeSearchText(dateText);
            const months = [
                'january', 'february', 'march', 'april', 'may', 'june',
                'july', 'august', 'september', 'october', 'november', 'december'
            ];
            const monthIndexByName = months.findIndex(month => normalized.includes(month));
            if (monthIndexByName !== -1) {
                return monthIndexByName;
            }
            const parsedDate = new Date(dateText);
            if (!isNaN(parsedDate.getTime())) {
                return parsedDate.getMonth();
            }
            return -1;
        }

        function doesMonthMatchQuery(query, quotationDate) {
            const tokens = normalizeSearchText(query).split(/\s+/).filter(Boolean);
            if (tokens.length === 0) {
                return false;
            }
            const queryMonthIndex = tokens.map(getMonthIndexFromToken).find(index => index !== -1);
            if (queryMonthIndex === undefined) {
                return false;
            }
            const quotationMonthIndex = getMonthIndexFromDateText(quotationDate);
            if (quotationMonthIndex === -1) {
                return false;
            }
            return queryMonthIndex === quotationMonthIndex;
        }

        function matchesApprovalSearch(quotation, query) {
            const normalizedQuery = normalizeSearchText(query);
            if (!normalizedQuery) {
                return true;
            }
            const companyName = normalizeSearchText(quotation.projectName);
            const kindAttn = normalizeSearchText(quotation.customerName);
            const quoteNumber = normalizeSearchText(quotation.quoteNumber);
            const combined = `${companyName} ${kindAttn} ${quoteNumber}`;
            if (combined.includes(normalizedQuery)) {
                return true;
            }
            return doesMonthMatchQuery(normalizedQuery, quotation.quotationDate || '');
        }

        function getFilteredApprovedQuotations(query) {
            const normalizedQuery = normalizeSearchText(query);
            if (!normalizedQuery) {
                return approvedQuotations.slice();
            }
            return approvedQuotations.filter(quotation => matchesApprovalSearch(quotation, normalizedQuery));
        }

        function getApprovalSearchInput() {
            return document.getElementById('approvalSearchInput');
        }

        function attachApprovalSearchListener() {
            const searchInput = getApprovalSearchInput();
            if (!searchInput || searchInput.dataset.bound === 'true') {
                return;
            }
            searchInput.addEventListener('input', function() {
                approvalSearchQuery = searchInput.value || '';
                displayAllApprovedQuotations();
            });
            searchInput.dataset.bound = 'true';
        }

        function buildApprovalSplitLayout({ quotation, termsText, approveButtonHTML, saveButtonHTML, downloadButtonHTML }) {
            const sidePanelHTML = buildApprovalSidePanelHTML(quotation);

            return `
                <div class="approval-layout">
                    <div class="approval-quotation">
                        ${quotation.headerHTML || ''}
                        ${quotation.tableHTML}
                        <div class="grand-total">
                            <span>Total: â‚¹${quotation.grandTotal}</span>
                        </div>
                        ${buildEditableTermsBoxHtml(termsText)}
                        <div style="margin-top: 10px; display: flex; gap: 10px; flex-wrap: wrap;">
                            ${approveButtonHTML}
                            ${saveButtonHTML || ''}
                            ${downloadButtonHTML}
                        </div>
                    </div>
                    <div class="approval-resize-handle" aria-label="Resize panels" style="height: 100%; background: #c7c7c7; align-self: stretch; min-height: 200px;"></div>
                    ${sidePanelHTML}
                </div>
            `;
        }

        function buildApprovalSidePanelHTML(quotation) {
            const emailBlock = quotation.emailContent || quotation.emailContentHtml
                ? `<div style="margin-top:10px;"><strong>Email Content</strong>${buildEmailContentPreviewHTML(quotation)}</div>`
                : '';
            const fileBlock = quotation.fileContent
                ? `<div style="margin-top:10px;"><strong>File Content</strong><div style="white-space: pre-wrap; font-size: 12px; background:#fafafa; border:1px solid #eee; padding:8px; border-radius:4px;">${escapeHtml(quotation.fileContent)}</div></div>`
                : '';
            const panelContent = emailBlock || fileBlock
                ? `${emailBlock}${fileBlock}`
                : `<div style="margin-top:10px; font-size: 12px; color:#777; background:#fafafa; border:1px dashed #ddd; padding:8px; border-radius:4px;">No email or file content available.</div>`;

            return `
                <div class="approval-side">
                    <div class="approval-drag-area">
                        <div class="approval-drag-panel" data-drag="email-panel">
                            <div class="approval-drag-handle">Drag to move</div>
                            <div class="approval-scroll-panel">
                                ${panelContent}
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }

        function updateEmailPreviewScroll(folderContent) {
            const quoteColumn = folderContent.querySelector('.approval-quotation');
            const emailPreview = folderContent.querySelector('.email-html-preview');
            if (!quoteColumn || !emailPreview) {
                return;
            }
            const quoteHeight = quoteColumn.getBoundingClientRect().height;
            if (!quoteHeight) {
                return;
            }
            const threshold = Math.max(quoteHeight * 0.5, 200);
            if (emailPreview.scrollHeight > threshold) {
                emailPreview.style.maxHeight = `${Math.floor(threshold)}px`;
                emailPreview.style.overflowY = 'auto';
            } else {
                emailPreview.style.maxHeight = '';
                emailPreview.style.overflowY = 'visible';
            }
        }

        function renderApprovedQuotationsHTML(container, allQuotationsHTML) {
            // Update the container
            container.innerHTML = allQuotationsHTML;
        }

        function updateApprovalContainerScrollLimit(container) {
            const folders = Array.from(container.querySelectorAll('.quotation-folder'));
            if (folders.length <= 10) {
                container.style.maxHeight = '';
                container.style.overflowY = '';
                return;
            }

            let totalHeight = 0;
            const visibleCount = Math.min(10, folders.length);
            for (let i = 0; i < visibleCount; i += 1) {
                totalHeight += folders[i].getBoundingClientRect().height;
            }
            totalHeight += 10; // small buffer for container padding
            container.style.maxHeight = `${Math.ceil(totalHeight)}px`;
            container.style.overflowY = 'auto';
        }

        function attachApprovalListeners() {
            // Attach event listeners to all editable fields in Approval section
            attachApprovalSectionListeners();
        }

        function displayAllApprovedQuotations() {
            /*
                This function loops through all approved quotations
                and displays them in the Approval section.
            */
            
            const container = getApprovedQuotationsContainer();
            
            // If no quotations, show message
            if (approvedQuotations.length === 0) {
                renderNoApprovedQuotationsMessage(container);
                return;
            }
            
            // Hide the "no quotations" message
            hideNoApprovedQuotationsMessage();
            
            // Build HTML for all approved quotations (latest first)
            attachApprovalSearchListener();
            const filteredQuotations = getFilteredApprovedQuotations(approvalSearchQuery);
            const sortedByNewest = filteredQuotations.slice().sort(function (a, b) {
                const aTime = a.updatedAt ? new Date(a.updatedAt).getTime() : (a.createdAt ? new Date(a.createdAt).getTime() : (Number(a.id) || 0));
                const bTime = b.updatedAt ? new Date(b.updatedAt).getTime() : (b.createdAt ? new Date(b.createdAt).getTime() : (Number(b.id) || 0));
                return bTime - aTime;
            });
            const allQuotationsHTML = buildAllApprovedQuotationsHTMLForList(sortedByNewest);
            
            // Update the container
            renderApprovedQuotationsHTML(container, allQuotationsHTML);
            
            // Attach event listeners to all editable fields in Approval section
            attachApprovalListeners();
            updateApprovalContainerScrollLimit(container);
        }
        
        /*
            ============================================
            ATTACH APPROVAL SECTION LISTENERS FUNCTION
            ============================================
            This function adds event listeners to all editable fields in the Approval section
            so that manual changes are automatically saved.
        */
        function attachApprovalSectionListeners() {
            /*
                This function:
                1. Finds all editable inputs in Approval section quotations
                2. Adds delete buttons and makes rate-per-mtr editable
                3. Adds Add Row buttons
                4. Adds change listeners to update quotation data
            */
            
            // Event delegation for delete-row buttons
            const container = document.getElementById('approvedQuotationsContainer');
            if (container && !container.dataset.approvalDeleteDelegationBound) {
                container.dataset.approvalDeleteDelegationBound = 'true';
                container.addEventListener('click', function(e) {
                    const btn = e.target.closest('.delete-row-btn');
                    if (!btn) return;
                    const row = btn.closest('tr');
                    const folder = btn.closest('.quotation-folder');
                    if (!row || !folder || !folder.id) return;
                    const quotationId = folder.id.replace('folder-', '');
                    e.preventDefault();
                    e.stopPropagation();
                    deleteApprovalRow(quotationId, row.id || row.getAttribute('data-row-id'));
                });
            }
            
            // Find all quotation folders in Approval section
            const quotationFolders = document.querySelectorAll('#approvedQuotationsContainer .quotation-folder');
            
            quotationFolders.forEach(function(folder) {
                // Get quotation ID from folder ID (format: folder-1234567890)
                const folderId = folder.id;
                const quotationId = folderId.replace('folder-', '');
                
                const folderContent = folder.querySelector('.quotation-folder-content');
                if (!folderContent) return;
                
                // Find the table in this quotation
                const table = folderContent.querySelector('table');
                if (table) {
                    // Check if table header has Actions column, if not add it
                    const headerRow = table.querySelector('thead tr');
                    if (headerRow && !headerRow.querySelector('th:last-child')?.textContent.includes('ACTIONS')) {
                        const actionsHeader = document.createElement('th');
                        actionsHeader.textContent = 'ACTIONS';
                        actionsHeader.style.width = '80px';
                        headerRow.appendChild(actionsHeader);
                    }
                    
                    // Remove unused leading control column from approved tables
                    if (headerRow) {
                        const firstHeaderCell = headerRow.querySelector('th:first-child');
                        const hasActionsHeader = headerRow.querySelector('th:last-child')?.textContent.includes('ACTIONS');
                        if (hasActionsHeader && firstHeaderCell && !firstHeaderCell.textContent.trim() && !firstHeaderCell.querySelector('input')) {
                            firstHeaderCell.remove();
                            const bodyRows = table.querySelectorAll('tbody tr');
                            bodyRows.forEach(function(row) {
                                if (row.classList.contains('pipe-type-header')) {
                                    const headerCell = row.querySelector('td[colspan]');
                                    if (headerCell) {
                                        const currentColspan = parseInt(headerCell.getAttribute('colspan') || '0', 10);
                                        if (currentColspan > 1) {
                                            headerCell.setAttribute('colspan', String(currentColspan - 1));
                                        }
                                    }
                                } else {
                                    const firstCell = row.querySelector('td:first-child');
                                    if (firstCell) {
                                        firstCell.remove();
                                    }
                                }
                            });
                        }
                    }
                    
                    // Make QTY and Rate headers editable
                    if (headerRow) {
                        const headerCells = headerRow.querySelectorAll('th');
                        headerCells.forEach(function(cell) {
                            const text = cell.textContent.trim();
                            let replacement = '';
                            if (text === 'QTY PER MTRS' || text === 'QTY PER MTR' || text === 'QTY (MTRS)' || text === 'QTY (Mtrs)') {
                                replacement = 'QTY (Mtrs)';
                            } else if (text === 'RATE PER MTRS' || text === 'RATE PER MTR' || text === 'Rate per mtrs' || text === 'Rate per mtr' || text === 'Rate per Mtr') {
                                replacement = 'Rate per Mtr';
                            }
                            if (replacement && !cell.querySelector('input')) {
                                const input = document.createElement('input');
                                input.type = 'text';
                                input.value = replacement;
                                input.style.width = '100%';
                                input.style.border = 'none';
                                input.style.background = 'transparent';
                                input.style.color = 'white';
                                input.style.fontWeight = 'bold';
                                cell.textContent = '';
                                cell.appendChild(input);
                            }
                        });
                    }
                    
                    // Update pipe type headers colspan
                    const pipeHeaders = table.querySelectorAll('.pipe-type-header td[colspan]');
                    pipeHeaders.forEach(header => {
                        const headerRow = table.querySelector('thead tr');
                        const targetColspan = headerRow ? headerRow.children.length : parseInt(header.getAttribute('colspan') || '0', 10);
                        if (targetColspan && parseInt(header.getAttribute('colspan')) !== targetColspan) {
                            header.setAttribute('colspan', String(targetColspan));
                        }
                    });
                    
                    // Add controls for pipe type header rows (replace Creation addRow/deleteRow)
                    const pipeHeaderRows = table.querySelectorAll('.pipe-type-header');
                    pipeHeaderRows.forEach(function(headerRow) {
                        if (!headerRow.id) {
                            headerRow.id = `approval-header-${quotationId}-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
                        }
                        const headerCell = headerRow.querySelector('td');
                        if (!headerCell) return;
                        const headerInput = headerRow.querySelector('[data-field="pipeTypeHeader"]');
                        if (headerInput && !headerRow.getAttribute('data-pipe-type')) {
                            headerRow.setAttribute('data-pipe-type', headerInput.value || 'Default');
                        }
                        var actions = headerCell.querySelector('.pipe-header-actions');
                        if (!actions) {
                            var oldContainer = headerCell.querySelector('div[style*="gap: 6px"], div[style*="gap:6px"]');
                            if (oldContainer) {
                                oldContainer.innerHTML = '';
                                oldContainer.className = 'pipe-header-actions';
                                oldContainer.style.cssText = 'display: flex; gap: 6px;';
                                actions = oldContainer;
                            } else {
                                actions = document.createElement('div');
                                actions.className = 'pipe-header-actions';
                                actions.style.cssText = 'display: flex; gap: 6px;';
                                headerCell.appendChild(actions);
                            }
                        }
                        actions.innerHTML = '';
                        const addItemBtn = document.createElement('button');
                        addItemBtn.type = 'button';
                        addItemBtn.textContent = 'âž•';
                        addItemBtn.title = 'Add item row';
                        addItemBtn.style.cssText = 'background: #4CAF50; color: white; border: none; padding: 4px 8px; cursor: pointer; border-radius: 3px; font-size: 12px;';
                        addItemBtn.onclick = function() {
                            const pipeValue = headerInput ? (headerInput.value || 'Default') : (headerRow.getAttribute('data-pipe-type') || 'Default');
                            addApprovalRow(quotationId, pipeValue, headerRow.id);
                        };
                        const addHeaderBtn = document.createElement('button');
                        addHeaderBtn.type = 'button';
                        addHeaderBtn.textContent = 'H+';
                        addHeaderBtn.title = 'Add pipe type';
                        addHeaderBtn.style.cssText = 'background: #2196F3; color: white; border: none; padding: 4px 8px; cursor: pointer; border-radius: 3px; font-size: 12px;';
                        addHeaderBtn.onclick = function() {
                            addApprovalRow(quotationId, '__NEW_HEADER__', headerRow.id);
                        };
                        const deleteHeaderBtn = document.createElement('button');
                        deleteHeaderBtn.type = 'button';
                        deleteHeaderBtn.textContent = 'ðŸ—‘ï¸';
                        deleteHeaderBtn.title = 'Delete pipe type';
                        deleteHeaderBtn.style.cssText = 'background: #f44336; color: white; border: none; padding: 4px 8px; cursor: pointer; border-radius: 3px; font-size: 12px;';
                        deleteHeaderBtn.onclick = function() {
                            deleteApprovalRow(quotationId, headerRow.id);
                        };
                        actions.appendChild(addItemBtn);
                        actions.appendChild(addHeaderBtn);
                        actions.appendChild(deleteHeaderBtn);
                    });
                    
                    // Process each item row (all tbody rows that aren't pipe-type-header)
                    const itemRows = table.querySelectorAll('tbody tr:not(.pipe-type-header)');
                    itemRows.forEach(function(row, index) {
                        if (!row.classList.contains('item-row')) row.classList.add('item-row');
                        if (!row.id) {
                            row.id = `approval-row-${quotationId}-${Date.now()}-${index}`;
                        }
                        var actionsCell = row.querySelector('.delete-row-btn')?.closest('td');
                        row.querySelectorAll('button[onclick*="addRow"], button[onclick*="deleteRow"]').forEach(function(b) {
                            var cell = b.closest('td');
                            b.remove();
                            if (cell && !cell.querySelector('button') && !cell.querySelector('input')) actionsCell = cell;
                        });
                        if (!row.querySelector('.delete-row-btn')) {
                            if (!actionsCell) {
                                actionsCell = document.createElement('td');
                                row.appendChild(actionsCell);
                            }
                            actionsCell.innerHTML = '';
                            actionsCell.style.cssText = 'text-align: center; vertical-align: middle; padding: 5px;';
                            const deleteBtn = document.createElement('button');
                            deleteBtn.type = 'button';
                            deleteBtn.className = 'delete-row-btn';
                            deleteBtn.textContent = 'ðŸ—‘ï¸';
                            deleteBtn.title = 'Delete row';
                            deleteBtn.style.cssText = 'background: #f44336; color: white; border: none; padding: 4px 8px; cursor: pointer; border-radius: 3px; font-size: 12px;';
                            actionsCell.appendChild(deleteBtn);
                        }
                        
                        // Make rate-per-mtr editable if it's a span
                        const ratePerMtrSpan = row.querySelector('.rate-per-mtr');
                        if (ratePerMtrSpan && ratePerMtrSpan.tagName === 'SPAN') {
                            const currentValue = ratePerMtrSpan.textContent.replace('â‚¹', '').replace(/,/g, '');
                            const input = document.createElement('input');
                            input.type = 'number';
                            input.className = 'editable-field rate-per-mtr';
                            input.setAttribute('data-field', 'finalRate');
                            input.value = currentValue;
                            input.min = '0';
                            input.step = '0.01';
                            input.style.width = '100px';
                            ratePerMtrSpan.parentNode.replaceChild(input, ratePerMtrSpan);
                        }
                        
                        // Make amount editable if it's a span
                        const lineTotalSpan = row.querySelector('.line-total');
                        if (lineTotalSpan && lineTotalSpan.tagName === 'SPAN') {
                            const currentValue = lineTotalSpan.textContent.replace('â‚¹', '').replace(/,/g, '');
                            const input = document.createElement('input');
                            input.type = 'number';
                            input.className = 'editable-field line-total-input';
                            input.setAttribute('data-field', 'lineTotal');
                            input.value = currentValue;
                            input.min = '0';
                            input.step = '0.01';
                            input.style.width = '100px';
                            lineTotalSpan.parentNode.replaceChild(input, lineTotalSpan);
                        }

                        // Make quantity editable if it's not already an input
                        const quantityField = row.querySelector('[data-field="quantity"]');
                        if (quantityField && quantityField.tagName !== 'INPUT') {
                            const currentValue = quantityField.textContent.replace(/,/g, '').trim();
                            const input = document.createElement('input');
                            input.type = 'number';
                            input.className = 'editable-field';
                            input.setAttribute('data-field', 'quantity');
                            input.setAttribute('data-pipe-type', row.getAttribute('data-pipe-type') || '');
                            input.setAttribute('data-row-id', row.id || '');
                            input.value = currentValue || '0';
                            input.min = '0';
                            input.step = '1';
                            quantityField.parentNode.replaceChild(input, quantityField);
                        }
                        
                        // Update row number
                        const rowNumberCell = row.querySelector('td:first-child');
                        if (rowNumberCell && !rowNumberCell.classList.contains('row-number')) {
                            rowNumberCell.classList.add('row-number');
                            rowNumberCell.textContent = index + 1;
                        }
                        
                        // Attach event listeners
                        const editableFields = row.querySelectorAll('.editable-field');
                        editableFields.forEach(function(field) {
                            const fieldName = field.getAttribute('data-field') || '';
                            if (fieldName === 'lineTotal') {
                                field.addEventListener('input', function() {
                                    this.dataset.manual = 'true';
                                });
                            }
                            if (fieldName === 'finalRate') {
                                field.addEventListener('input', function() {
                                    this.dataset.manual = 'true';
                                });
                            }
                            if (['quantity', 'unitRate', 'marginPercent'].includes(fieldName)) {
                                field.addEventListener('input', function() {
                                    recalculateApprovalQuotationTotals(quotationId, false);
                                });
                            }
                            field.addEventListener('blur', function() {
                                recalculateApprovalQuotationTotals(quotationId, false);
                            });
                        });
                    });
                    
                    // Add Add Row button if it doesn't exist
                    const existingAddBtn = folderContent.querySelector('.add-row-btn-approval');
                    if (!existingAddBtn && itemRows.length > 0) {
                        const addRowDiv = document.createElement('div');
                        addRowDiv.style.cssText = 'margin-top: 10px; text-align: right;';
                        addRowDiv.className = 'add-row-btn-approval';
                        const addBtn = document.createElement('button');
                        addBtn.textContent = 'âž• Add Row';
                        addBtn.style.cssText = 'background: #4CAF50; color: white; border: none; padding: 8px 16px; cursor: pointer; border-radius: 4px; font-size: 14px;';
                        addBtn.onclick = function() {
                            addApprovalRow(quotationId);
                        };
                        addRowDiv.appendChild(addBtn);
                        // Insert before grand total
                        const grandTotal = folderContent.querySelector('.grand-total');
                        if (grandTotal) {
                            grandTotal.parentNode.insertBefore(addRowDiv, grandTotal);
                        } else {
                            folderContent.appendChild(addRowDiv);
                        }
                    }
                }

                const autosaveInputs = folderContent.querySelectorAll('input, textarea');
                autosaveInputs.forEach(function(input) {
                    if (input.dataset.approvalAutosaveBound === 'true') {
                        return;
                    }
                    const handler = function() {
                        updateQuotationFromApprovalSection(quotationId, input);
                    };
                    input.addEventListener('change', handler);
                    input.addEventListener('blur', handler);
                    input.dataset.approvalAutosaveBound = 'true';
                });

                attachApprovalSidePanelDrag(folderContent);
                updateEmailPreviewScroll(folderContent);
                attachApprovalResizeHandle(folderContent);
            });
        }

        function attachApprovalSidePanelDrag(folderContent) {
            const dragPanel = folderContent.querySelector('.approval-drag-panel');
            const dragArea = folderContent.querySelector('.approval-drag-area');
            if (!dragPanel || !dragArea || dragPanel.dataset.dragBound === 'true') {
                return;
            }

            const handle = dragPanel.querySelector('.approval-drag-handle');
            if (!handle) {
                return;
            }

            dragArea.style.position = 'relative';
            const quotationColumn = folderContent.querySelector('.approval-quotation');
            const getQuoteHeight = () => quotationColumn ? quotationColumn.getBoundingClientRect().height : dragArea.getBoundingClientRect().height;
            const getMaxOffset = () => {
                const quoteHeight = getQuoteHeight();
                return Math.max(0, quoteHeight - dragPanel.offsetHeight);
            };
            dragArea.style.paddingBottom = `${getMaxOffset()}px`;
            dragPanel.style.position = 'absolute';
            dragPanel.style.left = '0';
            dragPanel.style.right = '0';
            dragPanel.style.top = '0px';
            dragPanel.style.transform = dragPanel.style.transform || 'translateY(0px)';
            dragPanel.style.willChange = 'transform';
            dragArea.style.minHeight = `${Math.max(dragArea.clientHeight, dragPanel.offsetHeight + getMaxOffset())}px`;

            let startY = 0;
            let startOffset = 0;
            let dragging = false;

            const onPointerMove = (event) => {
                if (!dragging) return;
                const delta = event.clientY - startY;
                const maxTop = getMaxOffset();
                const nextOffset = Math.min(Math.max(startOffset + delta, 0), maxTop);
                dragPanel.style.transform = `translateY(${nextOffset}px)`;
            };

            const onPointerUp = () => {
                if (!dragging) return;
                dragging = false;
                dragPanel.classList.remove('dragging');
                document.removeEventListener('pointermove', onPointerMove);
                document.removeEventListener('pointerup', onPointerUp);
            };

            handle.addEventListener('pointerdown', (event) => {
                event.preventDefault();
                dragging = true;
                dragPanel.classList.add('dragging');
                startY = event.clientY;
                const currentTransform = dragPanel.style.transform || 'translateY(0px)';
                const match = currentTransform.match(/translateY\((-?\d+(\.\d+)?)px\)/);
                startOffset = match ? parseFloat(match[1]) : 0;
                document.addEventListener('pointermove', onPointerMove);
                document.addEventListener('pointerup', onPointerUp);
            });

            dragPanel.dataset.dragBound = 'true';
        }

        function applyApprovalSideWidth(layout, sidePanel, widthPx) {
            if (!layout || !sidePanel) {
                return;
            }
            const safeWidth = Math.max(320, Math.min(widthPx, 900));
            sidePanel.style.flex = `0 0 ${safeWidth}px`;
            sidePanel.style.maxWidth = `${safeWidth}px`;
            layout.dataset.emailWidth = String(safeWidth);
        }

        function attachApprovalResizeHandle(folderContent) {
            const layout = folderContent.querySelector('.approval-layout');
            const handle = folderContent.querySelector('.approval-resize-handle');
            const sidePanel = folderContent.querySelector('.approval-side');
            if (!layout || !handle || !sidePanel || handle.dataset.bound === 'true') {
                return;
            }

            let startX = 0;
            let startWidth = 0;
            let resizing = false;

            const onMove = (event) => {
                if (!resizing) return;
                const delta = event.clientX - startX;
                applyApprovalSideWidth(layout, sidePanel, startWidth - delta);
            };

            const onUp = () => {
                if (!resizing) return;
                resizing = false;
                document.removeEventListener('pointermove', onMove);
                document.removeEventListener('pointerup', onUp);
            };

            handle.addEventListener('pointerdown', (event) => {
                event.preventDefault();
                resizing = true;
                startX = event.clientX;
                startWidth = sidePanel.getBoundingClientRect().width;
                document.addEventListener('pointermove', onMove);
                document.addEventListener('pointerup', onUp);
            });

            const storedWidth = parseInt(layout.dataset.emailWidth || '', 10);
            if (Number.isFinite(storedWidth)) {
                applyApprovalSideWidth(layout, sidePanel, storedWidth);
            }

            handle.dataset.bound = 'true';
        }
        
        /*
            ============================================
            DELETE APPROVAL ROW FUNCTION
            ============================================
            Deletes a row from the Approval section table
        */
        function deleteApprovalRow(quotationId, rowId) {
            const folder = document.getElementById('folder-' + quotationId);
            if (!folder) return;
            
            const row = document.getElementById(rowId);
            if (!row || (!row.classList.contains('item-row') && !row.classList.contains('pipe-type-header'))) {
                return;
            }
            if (!folder.contains(row)) {
                return;
            }
            
            if (confirm('Are you sure you want to delete this row?')) {
                if (row.classList.contains('pipe-type-header')) {
                    let nextRow = row.nextElementSibling;
                    while (nextRow && !nextRow.classList.contains('pipe-type-header')) {
                        const rowToRemove = nextRow;
                        nextRow = nextRow.nextElementSibling;
                        rowToRemove.remove();
                    }
                }
                row.remove();
                updateApprovalRowNumbers(quotationId);
                recalculateApprovalQuotationTotals(quotationId, false);
                updateQuotationFromApprovalSection(quotationId, null);
            }
        }
        
        /*
            ============================================
            UPDATE APPROVAL ROW NUMBERS FUNCTION
            ============================================
            Updates serial numbers in Approval section table
        */
        function updateApprovalRowNumbers(quotationId) {
            const folder = document.getElementById('folder-' + quotationId);
            if (!folder) return;
            
            const itemRows = folder.querySelectorAll('.item-row');
            itemRows.forEach(function(row, index) {
                const rowNumberCell = row.querySelector('.row-number');
                if (rowNumberCell) {
                    rowNumberCell.textContent = index + 1;
                }
            });
        }
        
        /*
            ============================================
            ADD APPROVAL ROW FUNCTION
            ============================================
            Adds a new empty row to the Approval section table
        */
        function addApprovalRow(quotationId, pipeType = null, insertAfterId = null) {
            const folder = document.getElementById('folder-' + quotationId);
            if (!folder) return;
            
            const folderContent = folder.querySelector('.quotation-folder-content');
            if (!folderContent) return;
            
            const table = folderContent.querySelector('table');
            if (!table) return;
            
            const tbody = table.querySelector('tbody');
            if (!tbody) return;
            
            if (pipeType === '__NEW_HEADER__') {
                const existingHeaderCell = table.querySelector('.pipe-type-header td[colspan]');
                const headerRow = table.querySelector('thead tr');
                const colspan = existingHeaderCell
                    ? existingHeaderCell.getAttribute('colspan')
                    : (headerRow ? headerRow.children.length : 8);
                const newHeaderRow = document.createElement('tr');
                newHeaderRow.className = 'pipe-type-header';
                newHeaderRow.id = `approval-header-${quotationId}-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
                newHeaderRow.setAttribute('data-pipe-type', 'Default');
                newHeaderRow.innerHTML = `
                    <td colspan="${colspan}">
                        <div style="display: flex; align-items: center; justify-content: space-between; gap: 10px;">
                            <input type="text" class="editable-field" data-field="pipeTypeHeader" value="Default" style="flex: 1; border: none; background: transparent; font-weight: bold;">
                            <div style="display: flex; gap: 6px;">
                                <button onclick="addApprovalRow('${quotationId}', 'Default', '${newHeaderRow.id}')" title="Add item row" style="background: #4CAF50; color: white; border: none; padding: 4px 8px; cursor: pointer; border-radius: 3px; font-size: 12px;">âž•</button>
                                <button onclick="addApprovalRow('${quotationId}', '__NEW_HEADER__', '${newHeaderRow.id}')" title="Add pipe type" style="background: #2196F3; color: white; border: none; padding: 4px 8px; cursor: pointer; border-radius: 3px; font-size: 12px;">H+</button>
                                <button onclick="deleteApprovalRow('${quotationId}', '${newHeaderRow.id}')" title="Delete pipe type" style="background: #f44336; color: white; border: none; padding: 4px 8px; cursor: pointer; border-radius: 3px; font-size: 12px;">ðŸ—‘ï¸</button>
                            </div>
                        </div>
                    </td>
                `;
                tbody.appendChild(newHeaderRow);
                attachApprovalSectionListeners();
                return;
            }
            
            // Get the last pipe type or use default
            const existingRows = folder.querySelectorAll('.item-row');
            let resolvedPipeType = pipeType || 'Default';
            if (!pipeType && existingRows.length > 0) {
                const lastRow = existingRows[existingRows.length - 1];
                resolvedPipeType = lastRow.getAttribute('data-pipe-type') || 'Default';
            }
            
            // Create new row
            const row = document.createElement('tr');
            row.className = 'item-row';
            const rowId = `approval-row-${quotationId}-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
            row.id = rowId;
            row.setAttribute('data-pipe-type', resolvedPipeType);
            
            const rowNumber = existingRows.length + 1;
            
            row.innerHTML = `
                <td class="row-number">${rowNumber}</td>
                <td>
                    <input type="text" 
                           class="editable-field" 
                           data-field="originalDescription"
                           data-pipe-type="${resolvedPipeType}"
                           data-row-id="${rowId}"
                           value="" placeholder="Enter description">
                </td>
                <td>
                    <input type="number" 
                           class="editable-field" 
                           data-field="quantity"
                           data-pipe-type="${resolvedPipeType}"
                           data-row-id="${rowId}"
                           value="0" 
                           min="0" 
                           step="1">
                </td>
                <td class="col-base-rate">
                    â‚¹<input type="number" 
                           class="editable-field" 
                           data-field="unitRate"
                           data-pipe-type="${resolvedPipeType}"
                           data-row-id="${rowId}"
                           value="0" 
                           min="0" 
                           step="0.01" style="width: 80px;">
                </td>
                <td class="col-margin">
                    <input type="number" 
                           class="editable-field" 
                           data-field="marginPercent"
                           data-pipe-type="${resolvedPipeType}"
                           data-row-id="${rowId}"
                           value="" 
                           min="0" 
                           step="0.01" style="width: 60px;">
                </td>
                <td>â‚¹<input type="number" 
                           class="editable-field rate-per-mtr" 
                           data-field="finalRate"
                           data-pipe-type="${resolvedPipeType}"
                           data-row-id="${rowId}"
                           value="0.00" 
                           min="0" 
                           step="0.01" style="width: 100px;"></td>
                <td>â‚¹<input type="number" 
                           class="editable-field line-total-input" 
                           data-field="lineTotal"
                           data-row-id="${rowId}"
value="0"
                            min="0" 
                            step="1" style="width: 100px;"></td>
                <td>
                    <button class="delete-row-btn" onclick="deleteApprovalRow('${quotationId}', '${rowId}')" title="Delete row" style="background: #f44336; color: white; border: none; padding: 4px 8px; cursor: pointer; border-radius: 3px; font-size: 12px;">ðŸ—‘ï¸</button>
                </td>
            `;
            
            if (insertAfterId) {
                const insertAfterRow = folderContent.querySelector('#' + insertAfterId);
                if (insertAfterRow && insertAfterRow.parentNode === tbody) {
                    let rowToInsertAfter = insertAfterRow;
                    if (insertAfterRow.classList.contains('pipe-type-header')) {
                        let next = insertAfterRow.nextElementSibling;
                        while (next && !next.classList.contains('pipe-type-header')) {
                            if (next.classList.contains('item-row')) rowToInsertAfter = next;
                            next = next.nextElementSibling;
                        }
                    }
                    rowToInsertAfter.insertAdjacentElement('afterend', row);
                } else {
                    tbody.appendChild(row);
                }
            } else {
                tbody.appendChild(row);
            }
            
            updateApprovalRowNumbers(quotationId);
            
            // Attach event listeners
            const editableFields = row.querySelectorAll('.editable-field');
            editableFields.forEach(function(field) {
                const fieldName = field.getAttribute('data-field') || '';
                if (fieldName === 'lineTotal') {
                    field.addEventListener('input', function() {
                        this.dataset.manual = 'true';
                    });
                }
                if (fieldName === 'finalRate') {
                    field.addEventListener('input', function() {
                        this.dataset.manual = 'true';
                    });
                }
                if (['quantity', 'unitRate', 'marginPercent'].includes(fieldName)) {
                    field.addEventListener('input', function() {
                        recalculateApprovalQuotationTotals(quotationId, false);
                    });
                }
                field.addEventListener('blur', function() {
                    recalculateApprovalQuotationTotals(quotationId, false);
                });
            });
            
            recalculateApprovalQuotationTotals(quotationId, false);
            updateQuotationFromApprovalSection(quotationId, null);
        }
        
        /*
            ============================================
            UPDATE QUOTATION FROM APPROVAL SECTION
            ============================================
            This function updates the quotation object when changes are made in Approval section.
        */
        function updateApprovalBadge(quotationId, quotation) {
            const folder = document.getElementById('folder-' + quotationId);
            if (!folder) {
                return;
            }
            const header = folder.querySelector('.quotation-folder-header span');
            if (!header) {
                return;
            }
            const existingBadge = header.querySelector('.saved-badge:not(.assigned-badge)');
            if (quotation.saved) {
                const checkedByName = quotation.checkedBy ? ` - ${quotation.checkedBy}` : '';
                if (existingBadge) {
                    existingBadge.textContent = `APPROVED${checkedByName}`;
                } else {
                    const badge = document.createElement('span');
                    badge.className = 'saved-badge';
                    badge.textContent = `APPROVED${checkedByName}`;
                    header.appendChild(badge);
                }
            } else if (existingBadge) {
                existingBadge.remove();
            }
        }

        function updateQuotationFromApprovalSection(quotationId, changedInput) {
            /*
                Parameters:
                - quotationId: The ID of the quotation being edited
                - changedInput: The input element that was changed
            */
            
            // Find the quotation in the array
            const quotationIndex = approvedQuotations.findIndex(function(q) {
                return idsMatch(q.id, quotationId);
            });
            
            if (quotationIndex === -1) {
                return; // Quotation not found
            }
            
            const quotation = approvedQuotations[quotationIndex];
            
            // Get the folder content element
            const folderContent = document.getElementById('folder-content-' + quotationId);
            if (!folderContent) {
                return;
            }
            
            // First, ensure all input values in the folder content are current
            const allInputs = folderContent.querySelectorAll('input, textarea');
            allInputs.forEach(function(input) {
                // For number inputs, preserve exact value
                if (input.type === 'number') {
                    input.setAttribute('value', input.value);
                } else {
                    input.setAttribute('value', input.value);
                }
                // For textarea, also update text content
                if (input.tagName === 'TEXTAREA') {
                    input.textContent = input.value;
                }
            });
            
            // Now clone the folder content with updated values
            const updatedContent = folderContent.cloneNode(true);
            
            // Update header HTML
            const headerElement = updatedContent.querySelector('.quotation-header');
            if (headerElement) {
                quotation.headerHTML = headerElement.outerHTML;
            }
            
            // Update table HTML
            const tableElement = updatedContent.querySelector('table');
            if (tableElement) {
                quotation.tableHTML = tableElement.outerHTML;
            }
            
            if (changedInput) {
                // Update terms text if it's a terms field
                if (changedInput.id === 'termsText' || changedInput.closest('.terms-box')) {
                    const termsTextarea = updatedContent.querySelector('.terms-box textarea');
                    if (termsTextarea) {
                        quotation.termsText = termsTextarea.value || '';
                    } else {
                        const termsElement = updatedContent.querySelector('.terms-box');
                        if (termsElement) {
                            quotation.termsText = termsElement.textContent || termsElement.innerText;
                        }
                    }
                }
                
                // Update specific fields based on input
                const inputId = changedInput.id;
                
                if (inputId === 'quotationDate') {
                    quotation.quotationDate = changedInput.value;
                } else if (inputId === 'preparedBy') {
                    quotation.preparedBy = changedInput.value;
                } else if (inputId === 'assignedTo') {
                    quotation.assignedTo = changedInput.value;
                } else if (inputId === 'checkedBy') {
                    quotation.checkedBy = changedInput.value;
                } else if (inputId === 'quoteNumber') {
                    quotation.quoteNumber = changedInput.value;
                } else if (inputId === 'kindAttn') {
                    quotation.customerName = changedInput.value;
                } else if (inputId === 'phoneNumber') {
                    quotation.phoneNumber = changedInput.value;
                    quotation.contactDetails = quotation.mobileNumber || quotation.phoneNumber || '';
                } else if (inputId === 'mobileNumber') {
                    quotation.mobileNumber = changedInput.value;
                    quotation.contactDetails = quotation.mobileNumber || quotation.phoneNumber || '';
                } else if (inputId === 'billTo') {
                    quotation.projectName = changedInput.value;
                } else if (inputId === 'shipTo') {
                    quotation.shipTo = changedInput.value;
                }
            }

            if (quotation.saved) {
                quotation.saved = false;
                updateApprovalBadge(quotationId, quotation);
            }
            quotation.updatedAt = new Date().toISOString();
            
            // Save to backend (debounced)
            saveToLocalStorage();
            scheduleQuotationBackendSave(quotation);
        }
        
        /*
            ============================================
            RECALCULATE APPROVAL QUOTATION TOTALS
            ============================================
            This function recalculates totals for a quotation in the Approval section.
        */
        function recalculateApprovalQuotationTotals(quotationId, shouldSave) {
            /*
                Parameters:
                - quotationId: The ID of the quotation to recalculate
                - shouldSave: Whether to persist changes (default: false)
            */
            
            if (shouldSave === undefined) {
                shouldSave = false;
            }
            
            const folderContent = document.getElementById('folder-content-' + quotationId);
            if (!folderContent) {
                return;
            }
            
            // Find all item rows in this quotation
            const itemRows = folderContent.querySelectorAll('.item-row');
            let grandTotal = 0;
            
            itemRows.forEach(function(row) {
                const quantity = parseFloat(row.querySelector('[data-field="quantity"]')?.value || 0) || 0;
                const unitRate = parseFloat(row.querySelector('[data-field="unitRate"]')?.value || 0) || 0;
                const marginValue = row.querySelector('[data-field="marginPercent"]')?.value || '';
                const marginPercent = marginValue === '' ? 0 : (parseFloat(marginValue) || 0);
                
                // Check if finalRate is editable (input) or calculated
                const finalRateInput = row.querySelector('[data-field="finalRate"]');
                let finalRate;
                const calculatedFromFormula = unitRate * (1 + marginPercent / 100);
                const calculatedOk = calculatedFromFormula === calculatedFromFormula && (unitRate > 0 || marginPercent !== 0);

                if (finalRateInput && finalRateInput.tagName === 'INPUT' && finalRateInput.dataset.manual === 'true') {
                    // User edited finalRate directly - use that value
                    const manualVal = parseFloat(finalRateInput.value || 0) || 0;
                    // If user cleared the field and we can calculate from base rate + margin, switch back to calculated
                    if (manualVal === 0 && calculatedOk) {
                        finalRateInput.dataset.manual = '';
                        finalRate = calculatedFromFormula;
                        finalRateInput.value = finalRate.toFixed(2);
                    } else {
                        finalRate = manualVal;
                    }
                } else {
                    // Calculate final rate from unitRate and margin
                    finalRate = calculatedOk ? calculatedFromFormula : 0;
                    if (finalRate !== finalRate) finalRate = 0;
                    const currentVal = finalRateInput ? (parseFloat(finalRateInput.value || 0) || 0) : 0;
                    // Don't overwrite with 0 when the row already has a non-zero rate (e.g. from AI or previous manual)
                    if (finalRate === 0 && currentVal > 0) {
                        finalRate = currentVal;
                    } else if (finalRateInput) {
                        finalRateInput.value = finalRate.toFixed(2);
                    }
                }
                
                // Calculate line total
                const lineTotalInput = row.querySelector('[data-field="lineTotal"]');
                let lineTotal = quantity * finalRate;
                if (lineTotal !== lineTotal) lineTotal = 0;
                if (lineTotalInput && lineTotalInput.tagName === 'INPUT' && lineTotalInput.dataset.manual === 'true') {
                    const manualLineTotal = parseFloat(lineTotalInput.value || 0) || 0;
                    if (quantity > 0) {
                        finalRate = manualLineTotal / quantity;
                        if (finalRate !== finalRate) finalRate = 0;
                        if (finalRateInput) {
                            finalRateInput.value = finalRate.toFixed(2);
                        }
                        lineTotal = quantity * finalRate;
                    } else {
                        lineTotal = manualLineTotal;
                    }
                    if (lineTotal !== lineTotal) lineTotal = 0;
                    lineTotalInput.dataset.manual = '';
                }
                lineTotal = roundAmountToWhole(lineTotal);
                
                const ratePerMtrElement = row.querySelector('.rate-per-mtr');
                if (ratePerMtrElement) {
                    if (ratePerMtrElement.tagName === 'INPUT') {
                        // Already an input, value is already set
                    } else {
                        ratePerMtrElement.textContent = formatIndianNumber(finalRate.toFixed(2));
                    }
                }
                
                if (lineTotalInput && lineTotalInput.tagName === 'INPUT') {
                    lineTotalInput.value = String(lineTotal);
                } else {
                    const lineTotalSpan = row.querySelector('.line-total');
                    if (lineTotalSpan) {
                        lineTotalSpan.textContent = formatIndianNumber(lineTotal, true);
                    }
                }
                
                grandTotal += lineTotal;
            });
            
            const grandTotalElement = folderContent.querySelector('.grand-total span');
            if (grandTotalElement) {
                grandTotalElement.textContent = `Total: â‚¹${formatIndianNumber(roundAmountToWhole(grandTotal), true)}`;
            }
            
            const quotationIndex = approvedQuotations.findIndex(function(q) {
                return idsMatch(q.id, quotationId);
            });
            
            if (quotationIndex !== -1) {
                approvedQuotations[quotationIndex].grandTotal = formatIndianNumber(roundAmountToWhole(grandTotal), true);
                if (shouldSave) {
                    saveToLocalStorage();
                }
            }
        }
        
        /*
            ============================================
            CLEAR CREATION SECTION FUNCTION
            ============================================
            This function clears the Creation section after quotation is approved.
        */
        function clearCreationSection() {
            /*
                This function:
                1. Hides the quotation content in Creation section
                2. Shows the "no quotation" message
                3. Clears all input fields
            */
            
            // Hide quotation content
            document.getElementById('creationQuotationHeader').style.display = 'none';
            document.getElementById('quotationTable').style.display = 'none';
            document.getElementById('creationGrandTotal').style.display = 'none';
            document.getElementById('creationApproveBtn').style.display = 'none';
            document.getElementById('termsDivider').style.display = 'none';
            document.getElementById('termsBox').style.display = 'none';
            
            // Show "no quotation" message
            const noCreationMsg = document.getElementById('noCreationQuotation');
            if (noCreationMsg) {
                noCreationMsg.style.display = 'block';
            }
            
            // Clear all header input fields
            document.getElementById('quotationDate').value = '';
            document.getElementById('billTo').value = '';
            document.getElementById('shipTo').value = '';
            document.getElementById('kindAttn').value = '';
            document.getElementById('emailContent').value = '';
            document.getElementById('fileUpload').value = '';
            document.getElementById('preparedBy').value = '';
            document.getElementById('assignedTo').value = '';
            document.getElementById('checkedBy').value = '';
            document.getElementById('quoteNumber').value = '';
            document.getElementById('phoneNumber').value = '';
            document.getElementById('mobileNumber').value = '';
            lastEmailContent = '';
            lastFileContent = '';
            
            // Clear terms and conditions
            if (document.getElementById('termsText')) {
                document.getElementById('termsText').value = '';
            }
            
            // Clear table body
            document.getElementById('quotationTableBody').innerHTML = '';
            document.getElementById('grandTotal').textContent = '0.00';
        }
        
        /*
            ============================================
            EXTRACT CONTACT NUMBER FUNCTION
            ============================================
            This function extracts the contact number from contact details string.
        */
        function extractContactNumber(contactDetails) {
            /*
                Parameter:
                - contactDetails: String containing contact information
                
                Returns: Contact number if found, or empty string
            */
            if (!contactDetails) {
                return '';
            }
            
            // Try to find phone number patterns
            // Common patterns: Phone: (555) 123-4567, Phone: 555-123-4567, Tel: 5551234567, etc.
            const phonePatterns = [
                /Phone:\s*\(?(\d{3})\)?\s*[-.]?\s*(\d{3})[-.]?\s*(\d{4})/i,
                /Tel:\s*\(?(\d{3})\)?\s*[-.]?\s*(\d{3})[-.]?\s*(\d{4})/i,
                /Mobile:\s*\(?(\d{3})\)?\s*[-.]?\s*(\d{3})[-.]?\s*(\d{4})/i,
                /(\d{3})[-.]?\s*(\d{3})[-.]?\s*(\d{4})/ // Generic pattern
            ];
            
            for (let pattern of phonePatterns) {
                const match = contactDetails.match(pattern);
                if (match) {
                    // Format as (XXX) XXX-XXXX
                    return `(${match[1]}) ${match[2]}-${match[3]}`;
                }
            }
            
            // If no phone number found, try to extract any number sequence
            const numberMatch = contactDetails.match(/\d{10,}/);
            if (numberMatch) {
                return numberMatch[0];
            }
            
            // Return empty string if no number found
            return '';
        }
        
        /*
            ============================================
            INDIAN NUMBER FORMATTING FUNCTION
            ============================================
            This function formats numbers with Indian numbering system (lakhs, crores).
            Example: 1234567 -> 12,34,567
        */
        function formatIndianNumber(num, wholeNumber) {
            /*
                - num: Number or string to format
                - wholeNumber: If true, format as integer (no decimals). Used for amount display.
            */
            const number = wholeNumber ? Math.round(parseFloat(num) || 0) : (parseFloat(num) || 0);
            const parts = wholeNumber ? [String(number), ''] : number.toFixed(2).split('.');
            const integerPart = parts[0];
            const decimalPart = parts[1] || '';
            
            let formatted = '';
            const reversed = integerPart.split('').reverse();
            for (let i = 0; i < reversed.length; i++) {
                if (i > 0 && i === 3) {
                    formatted = ',' + formatted;
                } else if (i > 3 && (i - 3) % 2 === 0) {
                    formatted = ',' + formatted;
                }
                formatted = reversed[i] + formatted;
            }
            return formatted + (decimalPart ? '.' + decimalPart : '');
        }
        
        /*
            Rounds an amount (line total or similar) to the nearest whole number.
            Used for amount display in both Creation and Approval sections (no decimals).
        */
        function roundAmountToWhole(value) {
            const n = parseFloat(value);
            return (n !== n || !isFinite(n)) ? 0 : Math.round(n);
        }
        
        /*
            ============================================
            PARSE TABLE DATA FUNCTION
            ============================================
            This function extracts line item data from the table HTML.
        */
        function parseTableData(tableHTML) {
            /*
                Parameter:
                - tableHTML: HTML string of the quotation table
                
                Returns: Array of line item objects
            */
            
            // Create a temporary DOM element to parse HTML
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = tableHTML;
            
            const lineItems = [];
            const rows = tempDiv.querySelectorAll('.item-row');
            
            rows.forEach(function(row) {
                const size = row.querySelector('[data-field="originalDescription"]')?.value || '';
                const quantity = row.querySelector('[data-field="quantity"]')?.value || '';
                const unitRate = row.querySelector('[data-field="unitRate"]')?.value || '';
                const marginPercent = row.querySelector('[data-field="marginPercent"]')?.value || '';
                const finalRate = row.querySelector('[data-field="finalRate"]')?.value || '';
                const lineTotal = row.querySelector('.line-total')?.textContent.replace('â‚¹', '').trim() || '';
                
                lineItems.push({
                    size: size,
                    quantity: quantity,
                    unitRate: unitRate,
                    marginPercent: marginPercent,
                    finalRate: finalRate,
                    lineTotal: lineTotal
                });
            });
            
            return lineItems;
        }
        
        /*
            ============================================
            SAVE QUOTATION CHANGES FUNCTION
            ============================================
            Saves edits made in the Approval section without approving.
        */
        function saveQuotationChanges(quotationId) {
            const quotationIndex = approvedQuotations.findIndex(function(q) {
                return idsMatch(q.id, quotationId);
            });
            if (quotationIndex === -1) {
                alert('Quotation not found!');
                return;
            }
            const quotation = approvedQuotations[quotationIndex];
            const folderId = 'folder-content-' + quotationId;
            const folderContent = document.getElementById(folderId);
            if (!folderContent) {
                alert('Cannot save: quotation content not found.');
                return;
            }
            const allInputs = folderContent.querySelectorAll('input, textarea');
            allInputs.forEach(function(input) {
                if (input.type === 'number') {
                    const normalizedValue = normalizeNumberValue(input.value);
                    input.value = normalizedValue;
                    input.setAttribute('value', normalizedValue);
                } else {
                    input.setAttribute('value', input.value);
                }
                if (input.tagName === 'TEXTAREA') {
                    input.textContent = input.value;
                }
            });
            recalculateApprovalQuotationTotals(quotationId, false);
            const updatedContent = folderContent.cloneNode(true);
            const headerElement = updatedContent.querySelector('.quotation-header');
            if (headerElement) {
                quotation.headerHTML = headerElement.outerHTML;
            }
            const tableElement = updatedContent.querySelector('table');
            if (tableElement) {
                quotation.tableHTML = tableElement.outerHTML;
            }
            const headerValues = getQuotationHeaderValuesFromContainer(folderContent);
            var domReadOk = (headerValues.customerName || '').toString().trim().length > 0;
            if (domReadOk) {
                function applyOrKeep(field, domVal) {
                    var v = (domVal || '').toString().trim();
                    if (v) quotation[field] = domVal;
                }
                applyOrKeep('quotationDate', headerValues.quotationDate);
                applyOrKeep('preparedBy', headerValues.preparedBy);
                applyOrKeep('assignedTo', headerValues.assignedTo);
                applyOrKeep('checkedBy', headerValues.checkedBy);
                applyOrKeep('quoteNumber', headerValues.quoteNumber);
                applyOrKeep('customerName', headerValues.customerName);
                applyOrKeep('phoneNumber', headerValues.phoneNumber);
                applyOrKeep('mobileNumber', headerValues.mobileNumber);
                applyOrKeep('projectName', headerValues.projectName);
                applyOrKeep('shipTo', headerValues.shipTo);
                if ((headerValues.contactDetails || '').toString().trim()) quotation.contactDetails = headerValues.contactDetails;
                else quotation.contactDetails = quotation.mobileNumber || quotation.phoneNumber || '';
                if ((headerValues.grandTotal || '').toString().trim()) quotation.grandTotal = headerValues.grandTotal;
                if ((headerValues.termsText || '').toString().trim()) quotation.termsText = headerValues.termsText;
            }
            quotation.updatedAt = new Date().toISOString();
            saveToLocalStorage();
            (async function() {
                const ok = await saveQuotationToBackend(quotation);
                if (ok) alert('Changes saved.');
            })().catch(function(e) {
                console.error('saveQuotationChanges async error:', e);
            });
        }

        /*
            ============================================
            SAVE QUOTATION FUNCTION
            ============================================
            This function saves a quotation to the backend as approved.
            Saved quotations appear as folders that can be opened.
        */
        function saveQuotation(quotationId) {
            /*
                Parameter:
                - quotationId: The unique ID of the quotation to save
                
                This function:
                1. Captures all current values from the Approval section
                2. Updates the quotation object with all changes
                3. Marks quotation as saved
                4. Saves to backend
                5. Updates display to show as folder
            */
            
            // Find the quotation in the array
            const quotationIndex = approvedQuotations.findIndex(function(q) {
                return idsMatch(q.id, quotationId);
            });
            
            if (quotationIndex === -1) {
                alert('Quotation not found!');
                return;
            }
            
            const quotation = approvedQuotations[quotationIndex];
            
            // Get the folder content element
            const folderContent = document.getElementById('folder-content-' + quotationId);
            if (folderContent) {
                // Ensure all input values are current before capturing
                const allInputs = folderContent.querySelectorAll('input, textarea');
                allInputs.forEach(function(input) {
                    // For number inputs, normalize the value to fix precision issues
                    if (input.type === 'number') {
                        const normalizedValue = normalizeNumberValue(input.value);
                        input.value = normalizedValue;
                        input.setAttribute('value', normalizedValue);
                    } else {
                        input.setAttribute('value', input.value);
                    }
                    // For textarea, also update text content
                    if (input.tagName === 'TEXTAREA') {
                        input.textContent = input.value;
                    }
                });
                
                // Recalculate totals to ensure grand total is current
                recalculateApprovalQuotationTotals(quotationId, false);
                
                // Clone the folder content with updated values
                const updatedContent = folderContent.cloneNode(true);
                
                // Update header HTML with current values
                const headerElement = updatedContent.querySelector('.quotation-header');
                if (headerElement) {
                    quotation.headerHTML = headerElement.outerHTML;
                }
                
                // Update table HTML with current values
                const tableElement = updatedContent.querySelector('table');
                if (tableElement) {
                    quotation.tableHTML = tableElement.outerHTML;
                }
                
                // Update specific fields from header inputs
                const headerInputs = folderContent.querySelectorAll('.quotation-header input');
                headerInputs.forEach(function(input) {
                    const inputId = input.id;
                    if (inputId === 'quotationDate') {
                        quotation.quotationDate = input.value;
                    } else if (inputId === 'preparedBy') {
                        quotation.preparedBy = input.value;
                    } else if (inputId === 'assignedTo') {
                        quotation.assignedTo = input.value;
                    } else if (inputId === 'checkedBy') {
                        quotation.checkedBy = input.value;
                    } else if (inputId === 'quoteNumber') {
                        quotation.quoteNumber = input.value;
                    } else if (inputId === 'kindAttn') {
                        quotation.customerName = input.value;
                    } else if (inputId === 'phoneNumber') {
                        quotation.phoneNumber = input.value;
                    } else if (inputId === 'mobileNumber') {
                        quotation.mobileNumber = input.value;
                    } else if (inputId === 'billTo') {
                        quotation.projectName = input.value;
                    } else if (inputId === 'shipTo') {
                        quotation.shipTo = input.value;
                    }
                });
                quotation.contactDetails = quotation.mobileNumber || quotation.phoneNumber || '';
                
                // Update grand total from the display
                const grandTotalElement = folderContent.querySelector('.grand-total span');
                if (grandTotalElement) {
                    const grandTotalText = grandTotalElement.textContent.replace('Total: â‚¹', '').replace(/,/g, '');
                    quotation.grandTotal = grandTotalText;
                }
            }
            
            // Mark quotation as saved (now it's approved)
            quotation.saved = true;
            
            // Save all quotations to backend (including this newly approved one with all updates)
            saveToLocalStorage();
            saveQuotationToBackend(quotation);
            
            // Update the display to show saved status (as folder)
            displayAllApprovedQuotations();
            
            // Scroll to the saved quotation folder
            const folderElement = document.getElementById('folder-' + quotationId);
            if (folderElement) {
                folderElement.scrollIntoView({ 
                    behavior: 'smooth',
                    block: 'center'
                });
            }
            
            // Show confirmation
            const contactNumber = extractContactNumber(approvedQuotations[quotationIndex].contactDetails);
            let filename = approvedQuotations[quotationIndex].customerName.trim();
            if (contactNumber) {
                filename += ` (${contactNumber})`;
            }
            alert(`Quotation saved as file: ${filename}`);
        }

        function parseQuotationTableForPdf(tableHTML) {
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = tableHTML || '';
            const rows = [];
            tempDiv.querySelectorAll('tbody tr').forEach(row => {
                if (row.classList.contains('pipe-type-header')) {
                    const headerInput = row.querySelector('[data-field="pipeTypeHeader"]');
                    const headerText = headerInput?.value || headerInput?.getAttribute('value') || row.textContent.trim();
                    if (headerText) {
                        rows.push({ type: 'pipe', text: headerText });
                    }
                    return;
                }
                if (!row.classList.contains('item-row')) {
                    return;
                }
                const getValue = (selector) => {
                    const el = row.querySelector(selector);
                    if (!el) return '';
                    if (el.tagName === 'INPUT' || el.tagName === 'TEXTAREA') {
                        return el.value || el.getAttribute('value') || '';
                    }
                    return el.textContent || '';
                };
                const sno = row.querySelector('.row-number')?.textContent?.trim() || '';
                const desc = getValue('[data-field="originalDescription"]').trim();
                const qty = getValue('[data-field="quantity"]').trim();
                const rate = getValue('[data-field="finalRate"]').trim();
                let amount = getValue('[data-field="lineTotal"]').trim();
                if (!amount) {
                    const lineTotalSpan = row.querySelector('.line-total');
                    amount = lineTotalSpan ? lineTotalSpan.textContent.trim() : '';
                }
                rows.push({
                    type: 'item',
                    sno,
                    desc,
                    qty,
                    rate,
                    amount
                });
            });
            return rows;
        }

        async function loadLogoDataUrl() {
            const logoImg = document.querySelector('.logo-placeholder img');
            let logoSrc = 'logo.png';
            if (logoImg && logoImg.getAttribute('src')) {
                logoSrc = logoImg.getAttribute('src');
            }
            try {
                logoSrc = new URL(logoSrc, window.location.href).toString();
            } catch (error) {
                return null;
            }
            return new Promise(resolve => {
                const img = new Image();
                img.crossOrigin = 'anonymous';
                img.onload = () => {
                    try {
                        const canvas = document.createElement('canvas');
                        canvas.width = img.width;
                        canvas.height = img.height;
                        const ctx = canvas.getContext('2d');
                        ctx.drawImage(img, 0, 0);
                        resolve(canvas.toDataURL('image/png'));
                    } catch (e) {
                        resolve(null);
                    }
                };
                img.onerror = () => resolve(null);
                img.src = logoSrc;
            });
        }

        /*
            ============================================
            DOWNLOAD QUOTATION AS PDF
            ============================================
            Text-based PDF generation (selectable text).
        */
        async function downloadQuotationPdf(quotationId) {
            const quotation = approvedQuotations.find(q => idsMatch(q.id, quotationId));
            if (!quotation) {
                alert('Quotation not found');
                return;
            }
            // Sync all manual edits from the folder DOM so the PDF reflects current content
            const folderContent = document.getElementById('folder-content-' + quotationId);
            if (folderContent) {
                recalculateApprovalQuotationTotals(quotationId, false);
                // Sync input/textarea values to value attributes so outerHTML serialization includes them (fixes blank rows in PDF)
                folderContent.querySelectorAll('input, textarea').forEach(function(input) {
                    if (input.type === 'number') {
                        const v = normalizeNumberValue(input.value);
                        input.setAttribute('value', v);
                        input.value = v;
                    } else {
                        input.setAttribute('value', input.value);
                    }
                    if (input.tagName === 'TEXTAREA') {
                        input.textContent = input.value;
                    }
                });
                const tableElement = folderContent.querySelector('table');
                if (tableElement) {
                    quotation.tableHTML = tableElement.outerHTML;
                }
                const grandTotalEl = folderContent.querySelector('.grand-total span');
                if (grandTotalEl) {
                    const gt = grandTotalEl.textContent.replace(/Total:\s*â‚¹/i, '').replace(/,/g, '').trim();
                    if (gt) quotation.grandTotal = gt;
                }
                const headerInputs = folderContent.querySelectorAll('.quotation-header input');
                headerInputs.forEach(function(input) {
                    const inputId = input.getAttribute('id') || input.getAttribute('data-field') || '';
                    const val = input.value || '';
                    if (inputId === 'quotationDate') quotation.quotationDate = val;
                    else if (inputId === 'preparedBy') quotation.preparedBy = val;
                    else if (inputId === 'assignedTo') quotation.assignedTo = val;
                    else if (inputId === 'checkedBy') quotation.checkedBy = val;
                    else if (inputId === 'quoteNumber') quotation.quoteNumber = val;
                    else if (inputId === 'kindAttn') quotation.customerName = val;
                    else if (inputId === 'phoneNumber') quotation.phoneNumber = val;
                    else if (inputId === 'mobileNumber') quotation.mobileNumber = val;
                    else if (inputId === 'billTo') quotation.projectName = val;
                    else if (inputId === 'shipTo') quotation.shipTo = val;
                });
                quotation.contactDetails = quotation.mobileNumber || quotation.phoneNumber || '';
                const termsEl = folderContent.querySelector('.terms-box textarea');
                if (termsEl) quotation.termsText = termsEl.value || '';
            }

            const { jsPDF } = window.jspdf || {};
            if (!jsPDF) {
                alert('PDF libraries not loaded. Please refresh and try again.');
                return;
            }

            const doc = new jsPDF('p', 'pt', 'a4');
            const pageWidth = doc.internal.pageSize.getWidth();
            const pageHeight = doc.internal.pageSize.getHeight();
            const margin = 30;
            const contentWidth = pageWidth - margin * 2;
            let cursorY = margin;

            const brand = { r: 59, g: 63, b: 121 };
            const softText = { r: 48, g: 48, b: 48 };
            const setBrandFill = () => doc.setFillColor(brand.r, brand.g, brand.b);
            const setBrandText = () => doc.setTextColor(brand.r, brand.g, brand.b);
            const setSoftText = () => doc.setTextColor(softText.r, softText.g, softText.b);

            const ensureSpace = (height) => {
                if (cursorY + height > pageHeight - margin) {
                    doc.addPage();
                    cursorY = margin;
                }
            };

            const formatNumber = (value, keepDecimals = false) => {
                const cleaned = String(value || '').replace(/â‚¹/g, '').replace(/,/g, '').replace(/\s+/g, '').trim();
                if (!cleaned || !/^\d+(\.\d+)?$/.test(cleaned)) {
                    return value || '';
                }
                let formatted = formatIndianNumber(cleaned);
                if (!keepDecimals) {
                    formatted = formatted.replace(/\.00$/, '');
                }
                return formatted;
            };

            const logoDataUrl = await loadLogoDataUrl();
            if (logoDataUrl) {
                const maxLogoSize = 56;
                const props = doc.getImageProperties(logoDataUrl);
                const ratio = props.width / props.height;
                let logoWidth = maxLogoSize;
                let logoHeight = maxLogoSize;
                if (ratio >= 1) {
                    logoHeight = maxLogoSize / ratio;
                } else {
                    logoWidth = maxLogoSize * ratio;
                }
                doc.addImage(logoDataUrl, 'PNG', margin, cursorY + (maxLogoSize - logoHeight) / 2, logoWidth, logoHeight);
            }
            doc.setFont('helvetica', 'bold');
            doc.setFontSize(12);
            setSoftText();
            doc.text('DSC PIPES AND TUBES PVT LTD', margin + 70, cursorY + 14);
            doc.setFont('helvetica', 'normal');
            doc.setFontSize(9);
            doc.text('REGD OFFICE: 7C, 7TH FLOOR, DOSHI TOWERS, NO:156', margin + 70, cursorY + 30);
            doc.text('P.H ROAD, KILAPUK, CHENNAI - 600 010', margin + 70, cursorY + 42);
            doc.text('EMAIL ID: info@dscpipes.com', margin + 70, cursorY + 54);
            doc.setFont('helvetica', 'bold');
            setSoftText();
            doc.setFontSize(16);
            doc.text('QUOTATION', pageWidth - margin, cursorY + 26, { align: 'right' });
            doc.setTextColor(0, 0, 0);
            cursorY += 70;
            doc.setDrawColor(brand.r, brand.g, brand.b);
            doc.setLineWidth(1);
            doc.line(margin, cursorY, pageWidth - margin, cursorY);
            cursorY += 14;

            doc.setFontSize(9);
            doc.setFont('helvetica', 'normal');
            const leftX = margin;
            const rightX = margin + contentWidth / 2 + 10;
            const rowGap = 12;
            const metaLeft = [
                ['QUOTATION DATE', quotation.quotationDate || ''],
                ['KIND ATTN', quotation.customerName || ''],
                ['PHONE NUMBER', quotation.phoneNumber || ''],
                ['MOBILE NUMBER', quotation.mobileNumber || '']
            ];
            const metaRight = [
                ['PREPARED BY', quotation.preparedBy || ''],
                ['ASSIGNED TO', quotation.assignedTo || ''],
                ['CHECKED BY', quotation.checkedBy || ''],
                ['QUOTE NUMBER', quotation.quoteNumber || '']
            ];
            metaLeft.forEach((row, idx) => {
                doc.text(row[0], leftX, cursorY + idx * rowGap);
                doc.text(row[1], leftX + 120, cursorY + idx * rowGap);
            });
            metaRight.forEach((row, idx) => {
                doc.text(row[0], rightX, cursorY + idx * rowGap);
                doc.text(row[1], rightX + 120, cursorY + idx * rowGap);
            });
            cursorY += Math.max(metaLeft.length, metaRight.length) * rowGap + 10;

            doc.setDrawColor(220);
            doc.setLineWidth(1);
            doc.line(margin, cursorY, pageWidth - margin, cursorY);
            cursorY += 12;
            doc.setFont('helvetica', 'bold');
            doc.text('Bill To', leftX, cursorY);
            doc.text('Ship To', rightX, cursorY);
            cursorY += 12;
            doc.setFont('helvetica', 'normal');
            doc.setFontSize(9);
            doc.text(quotation.projectName || '', leftX, cursorY);
            doc.text(quotation.shipTo || '', rightX, cursorY);
            cursorY += 18;

            const rows = parseQuotationTableForPdf(quotation.tableHTML);
            const colWidths = [35, 225, 70, 95, 110];
            const colLabels = ['S. NO', 'ITEMS AND DESCRIPTION', 'QTY (Mtrs)', 'Rate per Mtr (Rs.)', 'AMOUNT (Rs.)'];
            const colX = [
                margin,
                margin + colWidths[0],
                margin + colWidths[0] + colWidths[1],
                margin + colWidths[0] + colWidths[1] + colWidths[2],
                margin + colWidths[0] + colWidths[1] + colWidths[2] + colWidths[3]
            ];

            const drawHeader = () => {
                ensureSpace(22);
                setBrandFill();
                doc.setTextColor(255, 255, 255);
                doc.rect(margin, cursorY, contentWidth, 20, 'F');
                doc.setFont('helvetica', 'bold');
                doc.setFontSize(7);
                colLabels.forEach((label, idx) => {
                    const centerX = colX[idx] + colWidths[idx] / 2;
                    doc.text(label, centerX, cursorY + 13, { align: 'center' });
                });
                doc.setDrawColor(255);
                doc.setLineWidth(0.5);
                colX.slice(1).forEach(x => {
                    doc.line(x, cursorY, x, cursorY + 20);
                });
                doc.setTextColor(0, 0, 0);
                cursorY += 22;
            };

            doc.setCharSpace(0);
            drawHeader();

            rows.forEach((row, idx) => {
                if (row.type === 'pipe') {
                    ensureSpace(22);
                    setBrandFill();
                    doc.setTextColor(255, 255, 255);
                    doc.rect(margin, cursorY, contentWidth, 20, 'F');
                    doc.setFont('helvetica', 'bold');
                    doc.setFontSize(9);
                    doc.text(row.text, margin + 6, cursorY + 13);
                    doc.setTextColor(0, 0, 0);
                    cursorY += 22;
                    return;
                }
                const descLines = doc.splitTextToSize(row.desc || '', colWidths[1] - 10);
                const rowHeight = Math.max(18, descLines.length * 10 + 6);
                ensureSpace(rowHeight + 4);
                if (idx % 2 === 0) {
                    doc.setFillColor(245, 245, 245);
                    doc.rect(margin, cursorY, contentWidth, rowHeight, 'F');
                }
                doc.setFont('helvetica', 'normal');
                doc.setFontSize(9);
                doc.text(row.sno || '', colX[0] + 6, cursorY + 12);
                doc.text(descLines, colX[1] + 6, cursorY + 12);
                doc.text(formatNumber(row.qty, false), colX[2] + colWidths[2] - 6, cursorY + 12, { align: 'right' });
                doc.text(formatNumber(row.rate, true), colX[3] + colWidths[3] - 6, cursorY + 12, { align: 'right' });
                doc.text(formatNumber(roundAmountToWhole(row.amount), false), colX[4] + colWidths[4] - 6, cursorY + 12, { align: 'right' });
                doc.setDrawColor(230);
                doc.setLineWidth(0.5);
                doc.rect(margin, cursorY, contentWidth, rowHeight);
                colX.slice(1).forEach(x => {
                    doc.line(x, cursorY, x, cursorY + rowHeight);
                });
                cursorY += rowHeight;
            });

            ensureSpace(30);
            setBrandFill();
            doc.rect(margin, cursorY + 6, contentWidth, 22, 'F');
            doc.setTextColor(255, 255, 255);
            doc.setFont('helvetica', 'bold');
            doc.setFontSize(11);
            const formattedGrandTotal = formatIndianNumber(roundAmountToWhole(String(quotation.grandTotal || '0').replace(/,/g, '')), true);
            doc.text(`Total: Rs. ${formattedGrandTotal}`, pageWidth - margin - 6, cursorY + 21, { align: 'right' });
            doc.setTextColor(0, 0, 0);
            cursorY += 36;
            doc.setDrawColor(220);
            doc.setLineWidth(1);
            doc.line(margin, cursorY, pageWidth - margin, cursorY);
            cursorY += 16;

            const termsText = normalizeTermsText((quotation.termsText || '').trim());
            if (termsText) {
                ensureSpace(24);
                doc.setFont('helvetica', 'bold');
                doc.setFontSize(8);
                setSoftText();
                doc.text('TERMS AND CONDITIONS', margin, cursorY);
                cursorY += 14;
                doc.setFont('helvetica', 'normal');
                doc.setTextColor(0, 0, 0);
                doc.setFontSize(9);
                const termLines = doc.splitTextToSize(termsText, contentWidth);
                termLines.forEach(line => {
                    ensureSpace(12);
                    doc.text(line, margin, cursorY);
                    cursorY += 12;
                });
            }

            const filename = `Quotation-${quotation.customerName || 'Customer'}.pdf`;
            doc.save(filename);
        }
        
        /*
            ============================================
            TOGGLE QUOTATION FOLDER FUNCTION
            ============================================
            This function opens/closes a saved quotation folder.
        */
        function toggleQuotationFolder(quotationId) {
            /*
                Parameter:
                - quotationId: The unique ID of the quotation folder to toggle
            */
            
            const folderContent = document.getElementById('folder-content-' + quotationId);
            const toggleIcon = document.querySelector(`#folder-${quotationId} .folder-toggle-icon`);
            
            if (!folderContent || !toggleIcon) {
                return;
            }
            
            // Toggle the content visibility
            if (folderContent.classList.contains('show')) {
                // Close the folder
                folderContent.classList.remove('show');
                toggleIcon.classList.remove('open');
            } else {
                // Open the folder
                folderContent.classList.add('show');
                toggleIcon.classList.add('open');
            }
        }

        // Ensure logo loads correctly on localhost
        document.addEventListener('DOMContentLoaded', setLogoSource);
        document.addEventListener('DOMContentLoaded', attachEmailPasteListener);
        document.addEventListener('DOMContentLoaded', attachRateFilePreviewListener);
        // Ensure preview listener is attached when script runs after DOM load
        attachRateFilePreviewListener();
        renderSelectedRateFiles();
        
        /*
            ============================================
            SAVE TO LOCALSTORAGE FUNCTION
            ============================================
            This function is disabled; localStorage is not used.
        */
        function saveToLocalStorage() {
            // No-op: localStorage persistence is disabled.
        }
        
        /*
            ============================================
            LOAD FROM LOCALSTORAGE FUNCTION
            ============================================
            This function is disabled; localStorage is not used.
        */
        function loadFromLocalStorage() {
            // No-op: localStorage persistence is disabled.
        }
        
        /*
            ============================================
            ERROR HANDLING FUNCTIONS
            ============================================
            These functions show and hide error messages
        */
        function showError(message) {
            /*
                Shows an error message to the user
                
                Parameter:
                - message: The error text to display
            */
            const errorDiv = document.getElementById('errorMessage');
            errorDiv.textContent = message;
            errorDiv.classList.add('show');
        }
        
        function hideError() {
            /*
                Hides the error message
            */
            const errorDiv = document.getElementById('errorMessage');
            errorDiv.classList.remove('show');
        }
        
        /*
            ============================================
            GLOBAL VARIABLES
            ============================================
            Store all approved quotations in an array
        */
        
        // Array to store all approved quotations
        let approvedQuotations = [];
        let lastEmailContent = '';
        let lastFileContent = '';
        let lastEmailHtmlContent = '';
        let creationFolderState = {};
        let approvalSearchQuery = '';
        let defaultTermsText = (function() {
            const el = document.getElementById('termsText');
            return el ? el.value : '';
        })();
        
        /*
            ============================================
            INITIALIZATION
            ============================================
            Code that runs when the page loads
        */
        
        // This code runs when the page finishes loading
        console.log("Quotation Generator loaded successfully!");
        
        // Load saved quotations from backend
        initQuotations();
        
        // Load instructions from server
        loadInstructions();
        
        // Load default terms from server (sets defaultTermsText for new quotations)
        loadDefaultTerms();
        
        // Load and display uploaded files
        loadUploadedFiles();
        
        // Check current rate files status
        checkCurrentFiles();
    </script>
</body>
</html>

